% https://en.wikibooks.org/wiki/LaTeX/Colors
%\documentclass[handout,aspectratio=43]{beamer}
%\documentclass[aspectratio=43]{beamer}
\documentclass[handout,aspectratio=169,usenames,dvipsnames]{beamer}
%\documentclass[aspectratio=169,usenames,dvipsnames]{beamer}

% https://www.overleaf.com/learn/latex/Questions/How_do_I_adjust_the_font_size%3F
\usepackage{moresize}

% https://tex.stackexchange.com/questions/231439/beamer-how-to-make-font-larger-for-page-numbers
\setbeamerfont{headline}{size=\ssmall}
\setbeamerfont{footline}{size=\ssmall}

\usepackage[utf8] {inputenc}
\usepackage[T2A] {fontenc}
\usepackage[english,russian] {babel}
\usepackage{indentfirst,verbatim}
\usepackage{listings,amsmath,amsfonts,amssymb,multicol}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{proof}
\usepackage{soul} % https://tex.stackexchange.com/questions/23711/strikethrough-text
\usepackage{stmaryrd}
\usepackage{mathrsfs}
\usetikzlibrary{cd, babel}

% https://www.overleaf.com/learn/latex/Using_colours_in_LaTeX
\usepackage{xcolor}

\usetheme{CambridgeUS}
\usecolortheme{dolphin}

% https://9to5science.com/change-bullet-style-formatting-in-beamer
% https://tex.stackexchange.com/questions/185742/i-need-to-change-color-of-beamer-itemize-and-subitem-separately
%\setbeamertemplate{itemize items}[default]
%\setbeamertemplate{enumerate items}[default]
\setbeamertemplate{itemize item}{\scriptsize\raise1.25pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{itemize subitem}{\tiny\raise1.5pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{itemize subsubitem}{\tiny\raise1.5pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{enumerate item}{\insertenumlabel.}
\setbeamertemplate{enumerate subitem}{\insertenumlabel.\insertsubenumlabel}
\setbeamertemplate{enumerate subsubitem}{\insertenumlabel.\insertsubenumlabel.\insertsubsubenumlabel}

% https://tex.stackexchange.com/questions/642927/format-table-of-contents-in-beamer
\makeatletter
\setbeamertemplate{section in toc}{%
  \leavevmode%
  % prevents the period to be printed with the first/last section option
  \ifnum\beamer@tempcount>\beamer@toclastsection
  \else
  \ifnum\beamer@tempcount>0
    {\color{blue}\inserttocsectionnumber.}
  \fi\fi%
  \inserttocsection\par%
}
\setbeamertemplate{subsection in toc}{%
  \leavevmode%
  % prevents the period to be printed with the first/last section option
  \ifnum\beamer@tempcount>0
    {\hspace{1em}\color{BlueViolet}\scriptsize\raise1.25pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
  \fi%
  \inserttocsubsection\par%
}
\makeatother

% Make font smaller
% https://tex.stackexchange.com/questions/56768/how-to-set-a-small-default-font-size-with-beamer
%\geometry{paperwidth=140mm,paperheight=105mm}
\geometry{paperwidth=168mm,paperheight=105mm}

% Mk mathbf work https://tex.stackexchange.com/questions/166434/problem-with-the-mathbf-command
\usepackage{cmbright}
\fontencoding{OT1}\fontfamily{cmbr}\selectfont %to load ot1cmbr.fd
\DeclareFontShape{OT1}{cmbr}{bx}{n}{% change bx definition
<->cmbrbx10%
}{}
\normalfont % back to normalfont

\beamertemplatenavigationsymbolsempty

\newcommand{\backupbegin}{
   \newcounter{framenumbervorappendix}
   \setcounter{framenumbervorappendix}{\value{framenumber}}
}
\newcommand{\backupend}{
   \addtocounter{framenumbervorappendix}{-\value{framenumber}}
   \addtocounter{framenumber}{\value{framenumbervorappendix}}
}

\newcommand{\sectionplan}[1]{\section{#1}%
\frame[noframenumbering]{\tableofcontents[currentsection]}
}

\newcommand{\subsectionplan}[1]{\subsection{#1}%
\frame[noframenumbering]{\tableofcontents[currentsubsection]}
}

\newcommand{\haskellsn}[1]{\lstinline[language=Haskell]{#1}}

\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}

\newcommand{\funcExpr}[1]{\begingroup\color{blue}#1\endgroup}

\newcommand{\predicate}[1]{\begingroup\color{red}#1\endgroup}

\newcommand{\err}[0]{\textcolor{red}{ошибка}}

% https://tex.stackexchange.com/questions/116595/highlighting-haskell-listings-in-large-tex-document
\lstset{
  language=Haskell,
  basicstyle=\footnotesize,
  escapeinside={``}{``}
}

% Color code
% https://tex.stackexchange.com/questions/99475/how-to-invoke-latex-with-the-shell-escape-flag-in-texstudio-former-texmakerx
\usepackage{minted}
%\usemintedstyle{emacs}

% https://tex.stackexchange.com/questions/70448/dont-count-backup-slides
\usepackage{appendixnumberbeamer}

\author[Андрей Стоян]{Стоян Андрей Сергеевич\\ {\footnotesize руководитель:} Новожилов Дмитрий Павлович}
\institute[ИТМО/SE]{Национальный исследовательский университет ИТМО\\Разработка программного обеспечения/Software engineering}

\title[Дизайн и разработка Self-типов для языка Kotlin]{Дизайн и разработка Self-типов для языка Kotlin}
\date{Санкт-Петербург 2023г.}

\begin{document}

\maketitle

\begin{frame}{Содержание}
    \tableofcontents
\end{frame}


\section{Введение}

\subsection{Основные понятия}

\begin{frame}[fragile]{Ресиверы в Kotlin}
    \begin{block}{Ресивер функции}
        Объект, на котором функция может быть вызвана, и который доступен как \texttt{this} в её теле.
    \end{block}

    \pause
    \begin{columns}[onlytextwidth]
        \begin{column}{0.375\textwidth}
            \begin{block}{Dispatch ресивер}
                Ресивер, по которому происходит виртуальная диспетчеризация вызова: \pause
                \begin{minted}[escapeinside=??]{kotlin}
interface Base { fun greet() } ?\pause?
class Derived : Base {
    override fun greet() {
        println("Hello")
    }
} ?\pause?
val b: Base = Derived();
b.greet() // Печатает "Hello"
                \end{minted}
            \end{block}
        \end{column}\hfill%
        \pause
        \begin{column}{0.595\textwidth}
            \begin{block}{Extension ресивер}
                Не участвует в виртуальном вызове, нотация для передачи одного из параметров в функцию: \pause
                 \begin{minted}{kotlin}
fun String.twice() = this + this
// fun twice(String s) = s + s
println("Y".twice()) // Печатает "YY"
                 \end{minted}
            \end{block}
            \pause
            \begin{block}{Типовой scope}
                Перечень сигнатур функций, для которых объект данного типа может быть использован как ресивер:
                \begin{itemize}
                    \item \mintinline{kotlin}|(greet: Derived.() -> Unit)| $\in$ \mintinline{kotlin}|scope(Derived)|
                    \item \mintinline{kotlin}|(twice: String.() -> Unit)| $\in$ \mintinline{kotlin}|scope(String)|
                \end{itemize}
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Self-типы}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.47\textwidth}
            \vspace{-0em}
            \begin{block}{Self-тип}
                Тип, имеющий scope типа $D$ ресивера, на котором функция вызвана. \\ Если $B$ --- тип ресивера в декларации функции, то $D$ подтип $B$ (\underline{$D <: B$}).
                \pause
                \begin{minted}[escapeinside=??]{kotlin}
interface Base {
    fun base(): ?\framebox{Self}? = ?\framebox{this}?
} ?\pause?
class Defived : Base {
    fun derived() { /* ... */ }
} ?\pause?
fun Base.extension(): ?\framebox{Self}? = ?\framebox{this}? ?\pause?
fun test(d: Derived) =
  d.base()      /* scope(?\framebox{Derived}?) */
   .extension() /* scope(?\framebox{Derived}?) */
   .derived()
                \end{minted}
            \end{block}
        \end{column}\hfill%
        \begin{column}{0.50\textwidth}
            \pause
            \vspace{-0.6em}
            \begin{block}{Приземление Self-типа}
                Использование scope типа ресивера в месте вызова в качестве scope Self-типа. \pause

                \begin{itemize}
                    \item Оба Self-типа приземляются в \mintinline[escapeinside=??]{kotlin}|?\framebox{Derived}?|.
                \end{itemize}
            \end{block}

            \pause
            \begin{block}{Origin Self-типа}
                Назовём origin'ом Self-типа наиболее общий тип, в который Self может быть приземлён. \pause

                \begin{itemize}
                    \item Для обоих вхождений \mintinline[escapeinside=??]{kotlin}|?\framebox{Self}?| это \mintinline{kotlin}|Base| (обозначение \underline{\mintinline{kotlin}|Self(Base)|}).
                \end{itemize}
            \end{block}

            \pause
            \begin{block}{Система типов корректна/безопасна/sound}
                Всякая программа без приведений типов, в которой во время исполнения может возникнуть ошибка проверки типов, отвергается статической проверкой типов.
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Вариантность типовых параметров}
    \begin{block}{Вариантность типового параметра}
        \begin{itemize}
            \item Определят, в каких позициях можно использовать этот типовой параметр
            \item Задаёт отношение подтипизации между параметризованными типами
        \end{itemize}
    \end{block}

    \pause
    \begin{block}{Инвариантные типовые параметры: \mintinline[escapeinside=??]{kotlin}|interface Inv<T> { fun id(x: ?\framebox{T}?): ?\framebox{T}? }|}
        \begin{itemize}
            \item Можно использовать во входящих и исходящих позициях в декларациях методов
            \item Не устанавливает отношения подтипизации: \texttt{Inv<B> !<:> Inv<A>}
        \end{itemize}
    \end{block}

    \pause
    \begin{block}{Ковариантные типовые параметры: \mintinline[escapeinside=??]{kotlin}|interface Out<?\framebox{out}? T> { fun produce(): ?\framebox{T}? }|}
        \begin{itemize}
            \item Можно использовать только в исходящих позициях в декларациях методов
            \item Устанавливает прямое отношение подтипизации: \texttt{B <: A => Out<B> <: Out<A>}
        \end{itemize}
    \end{block}

    \pause
    \begin{block}{Контравариантные типовые параметры: \mintinline[escapeinside=??]{kotlin}|interface In<?\framebox{in}? T> { fun accept(x: ?\framebox{T}?) }|}
        \begin{itemize}
            \item Можно использовать только во входящих позициях в декларациях методов
            \item Устанавливает обратное отношение подтипизации: \texttt{B <: A => In<B> :> In<A>}
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Мотивация: сценарии использования}

\begin{frame}[fragile]{Персистентные коллекции и иммутабельные структуры}
    Стиль программирования с использованием персистентных коллекций и иммутабельных структур данных проще для восприятия и менее подвержен ошибкам, чем мутирующий. \pause

    \begin{minted}[escapeinside=??]{kotlin}
interface PCollection<out T> {
    fun add(x: @UV?\footnote{@UnsafeVariance}? T): ?\framebox{Self}? // исходящая позиция
} ?\pause?
interface PList<out T> : PCollection<T> {
    fun listSpecific() { /* ... */ }
} ?\pause?
fun <T> PList<T>.addTwiceSpecific(x: T) = this.add(x).add(x).listSpecific()
    \end{minted}

    \pause
    \vspace{0.5em}
    Альтернатива: переопределять каждый метод в каждом наследнике с более специфичным возвращаемым типом (\mintinline[escapeinside=??]{kotlin}|fun add(x: @UV): ?\framebox{PList<T>}?|).
    \begin{itemize}
        \item Существенное количество boilerplate code
        \item Нет контроля, что при добавлении метода в базовый класс также добавлен переопределяющий во всех наследниках
        \item Используется в библиотеке \href{https://github.com/Kotlin/kotlinx.collections.immutable}{\color{blue}kotlinx.collections.immutable}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Шаблон абстрактная фабрика (*)}
    Пусть требуется по элементу типизируемым образом получить породившую его фабрику.

    \begin{minted}[escapeinside=??]{kotlin}
abstract class Element<out F : Factory>(val factory: F) ?\pause?

interface Factory {
    fun create(): Element<?\framebox{Self}?> // ковариантная исходящая позиция
} ?\pause?
abstract class SpecificFactory : Factory {
    abstract fun doSpecific()
} ?\pause?
class ConcreteFactory : SpecificFactory() {
    override fun create(): Element<?\framebox{Self}?> = /* ... */
    override fun doSpecific() = /* ... */
} ?\pause?

fun <F : SpecificFactory> test(entity: Element<F>) {
    entity.factory.doSpecific()
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Шаблон наблюдатель (*)}
    \begin{columns}
        \begin{column}{0.48\textwidth}
            Абстрагируем логику регистрации и нотификации наблюдателей:
            \begin{minted}[escapeinside=??]{kotlin}
abstract class AbstractObservable {
    private val observers =
        mutableListOf<(Self) -> Unit>()

    // контравариантная входная позиция
    fun observe(
        observer: (?\framebox{Self}?) -> Unit
    ) {
        observers += observer
    } ?\pause?
    private fun notifyObservers() {
        observers.forEach { observer ->
            observer(?\framebox{this}?)
        }
    }
}
            \end{minted}
        \end{column}
        \pause
        \begin{column}{0.49\textwidth}
            \vspace{-0.5em}
            \begin{minted}[escapeinside=??]{kotlin}
class Entity : AbstractObservable {
    var color: Color = Color.Purple
        set(new: Color) {
            field = new
            notifyObservers()
        }
} ?\pause?

fun test() {
    val entity = Entity()
    entity.observe { it: ?\framebox{Entity}? ->
        // Сложнее ошибиться ссылкой
        println("New: ${it.color}")
    }
    // Печатает "New: Color.Blue"
    entity.color = Color.Blue
}
            \end{minted}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Рекурсивные структуры данных}
    Также Self-типы помогают строить рекурсивные структуры данных из вершин одного типа:
    \begin{minted}[escapeinside=??]{kotlin}
abstract class Node<out T>(val value: T, val children: List<?\framebox{Self}?>)
?\pause?
class BetterNode<out T>(value: T, children: List<?\framebox{Self}?> = emptyList()) :
    Node<T>(value, children) {
    fun doTheBest() = println(value)
}
?\pause?
fun test() {
    val betterTree = BetterNode(value = 2, children =
        listOf<?\framebox{BetterNode<Int>}?>(
            BetterNode(1, listOf(BetterNode(0))),
            BetterNode(4, listOf(BetterNode(3), BetterNode(5))))) ?\pause?
    betterTree.children
        .flatMap { it.children }
        .forEach { it.doTheBest() } // Печатает "0 3 5"
}
    \end{minted}
\end{frame}

\subsection{Обзор существующих решений}

\begin{frame}[fragile]{Рекурсивные дженерики}
    Self-типы могут быть эмулированы с помощью ковариантного типового параметра с рекурсивным ограничением:
    \begin{minted}[escapeinside=??]{kotlin}
interface PCollection<out E, ?\framebox{out Self : PCollection<E, Self>}?> {
    fun add(value: @UV E): ?\framebox{Self}?
} ?\pause?
fun <E, C> C.addAll(xs: Iterable<E>): C where ?\framebox{C : PCollection<E, C>}? =
    xs.fold(this) { acc, x -> acc.add(x) }
?\pause?
interface PList<out E, ?\framebox{out Self : PList<E, Self>}?> : PCollection<E, ?\framebox{Self}?> {
    fun listSpecific() { /* ... */ }
}
?\pause?
fun <T, L> L.addTwiceSpecific(x: T) where ?\framebox{L : PList<T, L>}? =
    this.add(x).add(x).listSpecific()
    \end{minted}
    \begin{itemize}
        \item Возникающий паттерн рекурсивного ограничения распространяется по всему коду
        \item Если origin это dispatch ресивер, требуется явное приведение типов: \mintinline[escapeinside=??]{kotlin}|this as Self|
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Self-типы в других языках (1)}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.48\textwidth}
            \begin{block}{Haskell, Rust, ...}
                Self-типы в языках без наследования реализаций тривиально подменяются на тип, для которого реализуется ограничение:
                \begin{minted}[escapeinside=??]{haskell}
class Inc ?\framebox{self}? where
  inc :: ?\framebox{self}? -> ?\framebox{self}?

instance Inc ?\framebox{Int}? where
  inc x = x + 1

incinc :: forall a. Inc a => a -> a
incinc = inc . (inc :: ?\framebox{a}? -> ?\framebox{a}?)
                \end{minted}
            \end{block}
        \end{column}\hfill%
        \begin{column}{0.49\textwidth}
            \pause
            \begin{block}{Python}
                \href{https://peps.python.org/pep-0673/}{\color{blue}Поддерживается}
                 только исходящая позиция.
            \end{block}
            \pause
            \begin{block}{TypeScript}
                Self-тип (\href{https://www.typescriptlang.org/docs/handbook/2/classes.html\#this-types}{\color{blue}this-тип}) можно писать в произвольной позиции, при этом безопасность системой типов не гарантируется.
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Self-типы в других языках (2)}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.44\textwidth}
            \begin{block}{Scala}
                \begin{itemize}
                    \item Термин ``Self-тип'' в Scala \href{https://docs.scala-lang.org/tour/self-types.html}{\color{blue} обозначает} совершенно другое
                    \item Нужное поведение можно эмулировать с помощью \href{https://docs.scala-lang.org/tour/abstract-type-members.html}{\color{blue}abstract type members} в одном наследнике с приведениями типов
                    \item Существует \href{https://github.com/lampepfl/dotty/issues/7374}{\color{blue}предложение} по добавлению This-типа в Scala3, пока без подробностей и \href{http://dotty.epfl.ch/}{\color{blue}документации}
                \end{itemize}
            \end{block}
        \end{column}\hfill%
        \pause
        \begin{column}{0.53\textwidth}
            \begin{block}{Swift}
                \begin{itemize}
                    \item Существует полная поддержка \href{https://docs.swift.org/swift-book/documentation/the-swift-programming-language/types/\#Self-Type}{\color{blue}Self-типов} для простой исходящей позиции
                    \item Протоколы\footnote{Протоколы --- механизм специального полиморфизма в Swift аналогичный трейтам или классам типов} могут включать self-типы в других позициях, но накладываемые ограничения сводят к ситуации отсутствия наследования реализации
                    \item \href{https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics/\#Associated-Types}{\color{blue}Ассоциированные типы} так же позволяют эмулировать Self-типы, но на один уровень иерархии и с дополнительными приведениями типа
                    \item Self-типы в расширениях ссылаются на расширяемый тип
                \end{itemize}
            \end{block}
        \end{column}
    \end{columns}
\end{frame}


\section{Цели и задачи}

\begin{frame}[fragile]{Цели и задачи}
    \begin{block}{Цель}
        Реализовать поддержку Self-типов для языка Kotlin.
    \end{block}
    \begin{block}{Задачи}
        \begin{enumerate}
            \item Составить дизайн-документ по интеграции Self-типов в Kotlin
            \item Реализовать поддержку Self-типов в компиляторе kotlinc (K2)
            \item Протестировать полученную реализацию
        \end{enumerate}
    \end{block}
\end{frame}


\section{Ход работы}

\subsection{Дизайн Self-типов: значения Self-типа}

\begin{frame}[fragile]{Некорректное создание новых объектов}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.46\textwidth}
            Для реализации персистентных и иммутабельных структур данных нужно иметь возможность создавать новый объект Self-типа. \pause

            \vspace{1em}
            \begin{block}{В общем случае небезопасно}
                \begin{itemize}
                    \item Создавать объект открытого\footnote{Открытый класс может иметь наследников} класса
                    \item Создавать объект другого класса
                \end{itemize}
            \end{block}
        \end{column}\hfill%
        \begin{column}{0.49\textwidth}
            \pause
            \begin{minted}[escapeinside=??]{kotlin}
open class A {
    fun newOfOpenA(): Self = A()
    fun newOtherQ(): Self = Q()
}

class Q : A() { fun qOnly() = Unit }
class P : A() { fun pOnly() = Unit }
?\pause?
fun test(q: Q, p: P) {
    q.newOfOpenA() /* scope типа Q */
     .qOnly()      /* ?\err? */ ?\pause?
    p.newOther()   /* scope типа P */
     .pOnly()      /* ?\err? */
}
            \end{minted}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Безопасное создание новых объектов типа \texttt{Self(C)}}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.51\textwidth}
            \vspace{-0.5em}
            \begin{block}{Smart-casts}
                \begin{minted}[escapeinside=??]{kotlin}
val x = A()
require(x is B) // Проверка типа
?\colorbox{green}{x}?.methodOfB() // x: A & B - пересечение
                \end{minted}
            \end{block}
            \pause
            \begin{block}{}
                Пусть \mintinline{kotlin}|this@decl| ссылается на ресивер ближайшей декларации (origin Self-типа)
            \end{block}
            \pause
            \begin{block}{Ограничения}
                \begin{itemize}
                    \item Класс \texttt{C} должен быть финальным\footnote{Финальный класс может иметь наследников}
                    \item Тип \mintinline{kotlin}|this@decl| либо равен \texttt{С}, либо является пересечением и содержит \texttt{C}
                    \item Тип \texttt{C} объявлен в том же модуле, в котором создаётся объект\footnote{Иначе открытие класса ломало бы совместимость}
                \end{itemize}
            \end{block}
        \end{column}\hfill%
        \begin{column}{0.46\textwidth}
            \pause
            \begin{minted}[escapeinside=??]{kotlin}
sealed interface Data {
    data class One(val a: Int) : Data

    data class Two(
        val a: Int, val b: Int
    ) : Data
?\pause?
    fun copy(): Self = when (this) {
        is One -> ?\colorbox{green}{One(a)}?
        is Two -> ?\colorbox{green}{Two(a, b)}?
    }
}
            \end{minted}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Правила подтипизации: некорректные присваивания}
    \begin{columns}[onlytextwidth]
        \begin{column}{0.99\textwidth}
            %\begin{block}{Некорректные присваивания}
                Если позволить присваивать Self-тип объекту отличному от ресивера, дальнейшее приземление Self-типа может приводить к небезопасности системы типов:
                \begin{minted}[escapeinside=??]{kotlin}
abstract class A {
    fun self(): Self = this // ok
    fun unsafeObj(a: A): Self = a
    fun unsafeSelf(a: A): Self = a.self() ?\pause?
}

class B : A() { fun bOnly() = Unit } ?\pause?

fun test(a: A, b: B) {
    b.unsageObj(a)  /* scope типа B */ .bOnly() // ?\err?, нет bOnly в A
    b.unsafeSelf(a) /* scope типа B */ .bOnly() // ?\err?, нет bOnly в A
}
                \end{minted}
            %\end{block}
        \end{column}\hfill%
        \begin{column}{0.0\textwidth}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Правила подтипизации}
    \begin{enumerate}
        \item \label{q} $B <: A \iff Self(B) <: Self(A)$
            \begin{itemize}
                \item Делает переопределение метода с Self-типом в исходдящей позиции корректным
                \item Логично следует из того, что $scope(A) \subset scope(B)$ и $scope(Self(A)) \subset scope(Self(B))$ \pause
            \end{itemize}
        \item $B <: A \iff Self(B) <: A$, чтобы разрешить \mintinline{kotlin}|val x: A = this| \pause
        \item \label{w} $Nothing <: Self(A)$ и $Self(A) <: Any$ \pause
        \item $B  ~!<: Self(A)$, если $B$ не подходит под правила (\ref{q}) и (\ref{w}) \pause
    \end{enumerate}

    \vspace{1em}
    Правило (\ref{w}) вместе с правилами приземления (далее) гарантируют, что только корректные значение имеют Self-тип.
\end{frame}

\subsection{Дизайн Self-типов: позиции Self-типов}

\begin{frame}{Ковариантные позиции}
content...
\end{frame}

\begin{frame}{Контравариантные позиции}
content...
\end{frame}

\subsection{Дизайн Self-типов: приземление Self-типов}

\begin{frame}{Приземление Self-типов}
content...
\end{frame}

\subsection{Реализация Self-типов в компиляторе kotlinc (K2)}

\begin{frame}{Архитектура компилятора K2}
content...
\end{frame}

\begin{frame}{Резолв Self-типа}
content...
\end{frame}

\begin{frame}{Scope Self-типа}
content...
\end{frame}

\subsection{Тестирование релизации}

\begin{frame}{Тестирование реализации}
content...
\end{frame}

\section{Результаты}

\begin{frame}{Результаты}
    \begin{itemize}
        \item Да бля
    \end{itemize}
\end{frame}


\appendix

\begin{frame}{Содержание дополнительных слайдов}
    \tableofcontents
\end{frame}

\section{Дополнительные слайды}

\begin{frame}{Материалы}
    \begin{enumerate}
        \item \href{https://youtrack.jetbrains.com/issue/KT-6494}{\color{blue} YouTrack feature request}
        \item \href{https://dl.acm.org/doi/10.1145/2888392}{\color{blue} Paper on topic of ThisType implementation in Java}
        \item \href{https://discuss.kotlinlang.org/t/self-types/371}{\color{blue} Discussion: java interoperability}
        \item \href{https://discuss.kotlinlang.org/t/this-type/1421}{\color{blue} Discussion: observer example}
        \item \href{https://medium.com/@jerzy.chalupski/emulating-self-types-in-kotlin-d64fe8ea2e62}{\color{blue} Emulating self types in Kotlin}
        \item \href{https://www.sitepoint.com/self-types-with-javas-generics/}{\color{blue} Self Types with Java’s Generics: self-types generic emulations drawbacks}
        \item \href{https://github.com/manifold-systems/manifold}{\color{blue} Self types via java plugin}
        \item \href{https://docs.swift.org/swift-book/documentation/the-swift-programming-language/types/\#Self-Type}{\color{blue} Swift language Self-type doc}
        \item \href{https://peps.python.org/pep-0673/}{\color{blue} Python language Self-types PEP}
        \href{https://www.typescriptlang.org/docs/handbook/2/classes.html\#this-types}{\color{blue}TypeScript this-тип}
        \item \href{https://maximgran.notion.site/maximgran/Self-types-58e89d6dda374ba9abb4483b192a49c2}{\color{blue} Self name resolve considerations (ru)}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Множественные ресиверы}
   У функции может быть до одного dispatch ресивера и сколько угодно extension ресиверов:
   \begin{minted}{kotlin}
class C : B() {
    fun String.greetSpecially() {
        greet(); println(this)
    }
}
// Печатает "Hello X"
with (B()) { " X".greetSpecially() }
   \end{minted}
\end{frame}

\begin{frame}[fragile]{Python}
                \begin{minted}{python}
Self = TypeVar("Self", bound="Shape")
class Shape:
    def set_scale(
        self: Self, scale: float
    ) -> Self:
        self.scale = scale
        return self
                \end{minted}
\end{frame}

\begin{frame}[fragile]{TypeScript}
                \begin{minted}{typescript}
class Box {
  sameAs(other: this): boolean { /* ... */ }
}
class DerivedBox extends Box {
  otherContent: string = "?";
  sameAs(other: this): boolean {
    if (other.otherContent === undefined) {
      console.log("broken")
    }
    ...
  }
}
const base = new Box();
const derived = new DerivedBox();
function test(x: Box): boolean {
  return x.sameAs(base)
}
test(derived) // Печатает "broken"
                \end{minted}
\end{frame}

\begin{frame}{Swift}
    \begin{itemize}
        \item Существует полная поддержка \href{https://docs.swift.org/swift-book/documentation/the-swift-programming-language/types/\#Self-Type}{\color{blue}Self-типов} для простой исходящей позиции \pause
        \item Для методов классов Self-тип доступен только для исходящей позиции \pause
        \item Если декларация метода протокола\footnote{Протоколы --- механизм специального полиморфизма как трейты или классы типов} содержит \href{https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics/\#Associated-Types}{\color{blue}ассоциированный тип} или Self-тип не в простой исходящей позиции: \pause
        \begin{itemize}
            \item Запрещено вызывать такие методы виртуально на \mintinline{swift}|any Protocol|
            \item Можно вызывать, если протокол является ограничением типового параметра или при мономорфизации на \mintinline{swift}|some Protocol|
            \item Реализующий класс обязан заменить такие вхождения Self-типа на себя
            \item Ситуация становится аналогична языкам без наследования
        \end{itemize} \pause
        \item Ассоциированные типы так же позволяют эмулировать Self-типы, но на один уровень иерархии и с дополнительными приведениями типа \pause
        \item Self-типы в расширениях ссылаются на расширяемый тип
    \end{itemize}
\end{frame}

\end{document}
