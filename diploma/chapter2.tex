\section{Анализ существующих реализаций Self-типов}

Как было показано выше, Self-типы с одной стороны имеют множество приложений, с другой~--- эмулируются в коде нетривиальным образом.
Поэтому не удивительно, что во многих языках Self-типы уже реализованы.

\begin{definition}
    \label{def:sound}
    \term{Безопасная (sound) система типов} --- всякая программа без приведений типов, в которой во время исполнения может возникнуть ошибка типизации, отвергается безопасной статической проверкой типов.
\end{definition}

Основной задачей, решаемой в следующей главе (\ref{sec:integration}), является максимизация возможностей, предоставляемых Self-типами, при сохранении безопасности системы типов (опр.~\ref{def:sound}) языка Kotlin.
Поэтому мы рассмотрим несколько объектно ориентированных языков с Self-типами и будем в первую очередь обращать внимание на позиции, в которых тот или иной язык позволяет использовать Self-типы, а так же на меры, предпринимаемые для сохранения безопасности системы типов.
В завершение увидим, что в языках без наследования поддержка Self-типов тривиальна с точки зрения безопасности системы типов.

\subsection{TypeScript}

В языке TypeScript~\cite{bierman2014understanding} Self-типы присутствуют под названием <<this-типы>>\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/classes.html\#this-types}}.
Они действуют так же, как было рассмотрено выше --- Self-тип материализуется в конкретный тип ресивера при вызове метода.

Однако разработчики TypeScript не ставят задачи поддержки безопасности системы типов в языке.
Поэтому нетрудно написать код, который использует this-тип в небезопасной позиции.
Так, можно без явных проведений типов получить значение \mintinline{typescript}|undefined| в программе.

\begin{minted}{typescript}
    class Box {
      content: string = "";
      sameAs(other: this): boolean {
        return other.content === this.content;
      }
    }

    class DerivedBox extends Box {
      otherContent: string = "?";
      sameAs(other: this): boolean {
        if (other.otherContent === undefined) {
          console.log("Система типов TS небезопасна")
        }
        return other.otherContent === this.otherContent;
      }
    }

    const base = new Box();
    const derived = new DerivedBox();

    function test(x: Box): boolean {
      return x.sameAs(base)
    }

    test(derived) // Печатает: "Система типов TS небезопасна"
\end{minted}

\subsection{Python}

Python~\cite{sanner1999python} --- изначально динамически типизированный язык программирования, в который последовательно добавляются возможности статической типизации.
В том числе в версию языка 3.11 были введены Self-типы\footnote{\url{https://peps.python.org/pep-0673/}\label{foot:self-pep}}.

Также авторы дизайн-предложения Self-типов для Python приводят\footref{foot:self-pep} интересную статистику, согласно которой паттерн типового параметра с рекурсивным ограничением (отчасти заменяемый Self-типами) встречается в количестве 40\% случаев от использования других популярных типов~--- \mintinline{Python}|dict| и \mintinline{Python}|Callable|.

Стратегия реализации Self-типов в Python заключается в превращении их обратно в \mintinline{Python}|TypeVar| с рекурсивным ограничением\footref{foot:self-pep}.

Аналогично TypeScript Self-типы в Python небезопасны.

\subsection{Java Manifold}

Плагин Manifold к компилятору Java позволяет\footnote{\url{https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext\#the-self-type-with-self}} проаннотировать тип аннотацией \mintinline{Java}|@Self|.
Проаннотированный тип играет роль bound'а (опр.~\ref{def:bound}) Self-типа.

С помощью аннотации \mintinline{Java}|@Self| Manifold позволяет ввести некоторые дополнительные типовые ограничения.

\begin{minted}{java}
    class A {
        public boolean equals(@Self Object obj) {
            /* ... */
        }
    }

    A a = new A();
    a.equals("строчка вместо объекта типа A"); // Ошибка компиляции
\end{minted}

Однако эти ограничения легко обойти.
Так, следующий код уже не отвергается системой типов.

\begin{minted}{java}
    Object obj = a;
    obj.equals("строчка вместо объекта типа A");
\end{minted}

Также Manifold избавляет от необходимости написания abstract override методов (см.~\ref{subsubsec:abstract-override}), если метод возвращает Self-тип.

Manifold предоставляет возможность писать функции-расширения в Java, и в связи с этим, \mintinline{Java}|@Self| может ссылаться на тип ресивера функции-расширения.

\begin{minted}{java}
    public static <K,V> @Self Map<K,V> add(
            @This Map<K,V> thiz, K key, V value) {
        thiz.put(key, value);
        return thiz;
    }

    HashMap<String, String> map = new HashMap<>()
        .add("nick", "grouper")
        .add("miles", "amberjack");
\end{minted}

\subsection{Java Core}

methods precisely because their type systems
do not support explicit recursive types, which lead to a mismatch between subclassing and subtyping. This
mismatch means that an expression of a subclass may not always be usable in a context where an expression
of a superclass is expected, which is not intuitive in an object-oriented setting.

even in the presence of negative occurrences of type
recursion variables by distinguishing object types from existential object types.

recursive types break a valuable property subtyping-by-
subclassing (or subtyping-by-inheritance) of object-oriented languages
William R. Cook, Walter Hill, and Peter S. Canning. 1990. Inheritance is not subtyping. In Proceedings of

less precise “declared inexact types” rather than precise “runtime
exact types”?

TODO % TODO

\cite{ryu2016thistype}

\subsection{Swift}

TODO % TODO

\subsection{Языки без наследования}

В языках без наследования и с поддержкой специального полиморфизма через классы типов или трейты Self-типы присутствуют как ссылки на тип, для которого реализуется тот или иной класс типов.

Для примера рассмотрим аналог Self-типов в языке Haskell.


\begin{minted}{haskell}
    class Show #\framebox{a}# where
      show :: #\framebox{a}# -> String

    data Data = Data Int

    instance Show #\framebox{Data}# where
      show :: #\framebox{Data}# -> String
      show (Data x) = "Data(" <> show x <> ")"

    concatenate :: Show a => a -> a -> String
    concatenate x y = show x <> ", " <> show y
\end{minted}

TODO % TODO
