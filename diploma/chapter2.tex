\section{Формализация Self-типов} \label{sec:theory}

В этой главе мы рассмотрим некоторое формальное представление типов объектов и наследования.
Это, во-первых, позволит понять, с какими сложностями может быть связано добавление Self-типов в язык.
Во-вторых, даст возможность далее описать существующие решения обнаруженных проблем (глава~\ref{sec:impls}), многие из которых оснащены доказательствами безопасности предлагаемых систем типов.
И наконец, мы сможем, быть более уверенными в интеграции Self-типов в Kotlin (глава~\ref{sec:integration}), благодаря выстраиванию соотношения технических решений с формальными верифицированными построениями.

Существует множество различных попыток формализации объектно ориентированного программирования как в рамках лямбда-исчисления, так и в виде отдельных исчислений~\cite{pierce2002types}.
Однако выбор конкретного формализма становится важен лишь в случае намерения производить формальные рассуждения, что не является задачей данной работы.
Мы не будем перегружать описание строгостью, цель данной главы~--- продемонстрировать идею построения такого рода формализмов.


\subsection{Записи в $\lambda$-исчислении} \label{subsec:records}

Возьмём классическое просто типизированное лямбда-исчисление (STLC~\cite{pierce2002types}) и расширим его сперва записями.

\term{Терм записи} имеет вид \[\{x_1 = v_1,\ldots,x_n = v_n\}\] где $x_i$~--- идентификаторы полей, а $v_i$~--- термы, значения полей.

\term{Терм доступа к полю} имеет вид $t.x_i$, где $t$~--- терм, а $x_i$~--- идентификатор поля, к которому производится доступ.

\term{Тип терма записи имеет вид} \[\{x_1 : \sigma_1,\ldots,x_n : \sigma_n\}\] где $x_i$~--- идентификаторы полей, а $\sigma_i$~--- типы значений полей.

\term{Правило (структурной) подтипизации для типов записей} записывается следующим образом:
\begin{equation}
    \label{eq:record-subtype}
    %! suppress = EscapeAmpersand
    \infer{
        \{x_1 : \sigma_1, \ldots, x_k : \sigma_k, \ldots, x_n : \sigma_n\}
        <:
        \{x_1 : \tau_1, \ldots, x_k : \tau_n\}
    }{\sigma_1 <: \tau_1 & \ldots & \sigma_k <: \tau_k}
\end{equation}

В формальной модели мы будем оперировать структурной подтипизацией вместо номинативной, так как нас интересует внутренняя структура объектов и возможность использовать один объект вместо другого (см.
~опр.~\ref{def:subtype}).

Существуют различные кодировки типов объектов в лямбда-исчислении.
Большинство из них так или иначе опираются на типы записей, имея различие в том, принимают ли методы явно ссылку на объект, или уже содержат её в замыкании.
В нашем изложении это не играет принципиальной роли, поэтому для краткости записи будем предполагать второе.
Тогда объект точки, содержащий координату и мутирующий метод перемещения можно протипизировать следующим образом:
\begin{equation}
    \label{eq:mutable-point}
    \{ x : int, move : int \to unit \}
\end{equation}

Будем считать тип \term{типом объекта наследника}, если он содержит все те же метки базового типа с не менее специфичными соответствующими типами, а так же, может быть, новые метки.


\subsection{Рекурсивные типы} \label{subsec:recursive-types}

Объект точки в предыдущем примере был изменяемым.
Тип чисто функционального объекта точки мог бы выглядеть следующим образом (добавим так же метод сравнения на равенство, пригодится в дальнейшем):
\begin{equation*}
    P = \{ x : int, move : int \to P, eq : P \to bool \}
\end{equation*}
Но поскольку мы выбрали структурную типизацию, мы не можем в правой части использовать то же имя --- так мы задаём бесконечное типовое дерево.
Чтобы получить конечный тип, используется $\mu$-нотация:
\begin{equation}
    \label{eq:P}
    P = \mu t \ldotp \{ x : int, move : int \to t, eq : t \to bool \}
\end{equation}

Воспользоваться значением $\mu$-типа можно с помощью \term{правила развёртки}~\cite{cook1989inheritance}:
\begin{equation}
    \label{eq:unfold}
    %! suppress = EscapeAmpersand
    \infer[\text{Unfold}]{
        \Delta \vdash unfold(o) : [t \mapsto U]T
    }{
        U = \mu t \ldotp T & \Delta \vdash o : U
    }
\end{equation}

Так, чтобы получить смещённую точку относительно точки $p : P$ требуется применить правило Unfold:
\begin{align}
    &unfold~p : \{ x : int, move : int \to P, eq : P \to bool \} \\
    \label{eq:unfold-example} &(unfold~p).move~42 : P
\end{align}

Нетрудно видеть, что связанные в $\mu$-нотации типы --- это не что иное, как Self-типы.

Мы пользуемся вариантом \term{изорекурсивных типов} (с явным применением развёртки через $unfold$) вместо \term{эквирекурсивных} из-за большей наглядности и простоты в реализации~\cite{pierce2002types}.


\subsection{Подтипизация рекурсивных типов} \label{subsec:rec-subtyping}

Классическое определение подтипизации между изорекурсивными типами было предложено в языке Amber~\cite{cardelli2005amber}:
\begin{equation}
    \label{eq:amber-rule}
    %! suppress = EscapeAmpersand
    \infer[\text{Amber}]{
        \Delta \vdash \mu t \ldotp \tau <: \mu u \ldotp \sigma
    }{
        t \neq u & t, u \notin freeVars(\Delta) & \Delta, t <: u \vdash \tau <: \sigma
    }
\end{equation}

Возьмём объект-наследник $p'$ точки $p : P$~\eqref{eq:P}, содержащий метод вычисления расстояния до другой точки.
Он будет иметь следующий тип:
\begin{equation}
    \label{eq:P'}
    P' = \mu t \ldotp \{ x : int, move : int \to t, eq : t \to bool, dist : t \to int \}
\end{equation}

Однако нетрудно видеть, что $p' : P'$ является наследником $p : P$, но не является его подтипом~\cite{cook1989inheritance}.
Это связано с тем, что в методе $eq$ рекурсивный тип присутствует в контравариантной позиции (слева от функциональной стрелки), а значит, его тип в $p'$ будет супертипом типа $eq$ в первом объекте, а не подтипом, как того требует правило~\eqref{eq:amber-rule}.

Таким образом, Self-тип безопасно использовать только в ковариантных позициях декларациях методов класса (опр.~\ref{def:type-position-sign}).
Поэтому в языках с наследованием требуется предпринимать специальные меры по обеспечению безопасности системы типов, так как наследник, как правило, автоматически считается подтипом.
Заметим, что для языков без наследования (таких, как Rust, Haskell и т.д.) обозначенная проблема не актуальна.


\subsection{Экзистенциальные типы} \label{subsec:existentials}

Экзистенциальные типы используются как механизм построения абстракций путём сокрытия деталей конкретного типа или всего типа целиком.
Как правило, в ООП языках если переменная имеет статический тип $U$, то во время исполнения её значение может иметь тип любого подтипа $U$ (\term{неточные типы, inexact types}).
В нотации экзистенциальных типов тип времени исполнения можно записать следующим образом:
\[
    \exists X <: U \ldotp X
\]

Иногда вместо отношения $<:$ используются какие-то другие, нас будут интересовать бинарные асимметричные отношения, обозначим их как $\blacktriangleleft$.

Вспомним, что типом объекта мы считаем рекурсивный тип записи, то есть тип $U$ может иметь вид $U = \mu x \ldotp T$.
Чтобы воспользоваться таким объектом требуется определить правило развёртки для экзистенциального типа с рекурсивным ограничением.
Сделаем это консистентно обычному правилу развёртки~\eqref{eq:unfold}:
\begin{equation}
    \label{eq:unfold-ex}
    %! suppress = EscapeAmpersand
    \infer[\text{Unfold-Ex}]{
        \Delta \vdash unfold(o) : [t \mapsto U']T
    }{
        U = \mu t \ldotp T
        &
        U' = \exists X \blacktriangleleft U \ldotp X
        &
        \Delta \vdash o : U'
    }
\end{equation}
