\section{Анализ существующих реализаций Self-типов}

Как было показано выше, Self-типы с одной стороны имеют множество приложений, с другой~--- эмулируются в коде нетривиальным образом.
Поэтому не удивительно, что во многих языках Self-типы уже реализованы.

Основной задачей, решаемой в следующей главе (\ref{sec:integration}), является максимизация возможностей, предоставляемых Self-типами, при сохранении безопасности системы типов (опр.~\ref{def:sound}) языка Kotlin.
Поэтому мы рассмотрим несколько объектно ориентированных языков с Self-типами и будем в первую очередь обращать внимание на значения Self-типа, позиции, в которых тот или иной язык позволяет использовать Self-типы, а так же на меры, предпринимаемые для сохранения безопасности системы типов.
В завершение увидим, что в языках без наследования поддержка Self-типов тривиальна с точки зрения безопасности системы типов.

\subsection{Формальные решения} \label{subsec:formal-solutions}

TODO % TODO

\subsection{TypeScript}

В языке TypeScript~\cite{bierman2014understanding} Self-типы присутствуют под названием <<this-типы>>\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/classes.html\#this-types}}.
Они действуют так же, как было рассмотрено выше --- this-тип материализуется в конкретный тип ресивера при вызове метода.

Однако разработчики TypeScript не ставят задачи поддержки безопасности системы типов языка и this-типы можно использовать в произвольной позиции.
Поэтому нетрудно написать код, например, с this-типом в контравариантной позиции, который проходит проверку типов, но при этом получающий без явных приведений типов значение \mintinline{typescript}|undefined|.

\begin{minted}{typescript}
    class Box {
      content: string = "";
      sameAs(other: this): boolean {
        return other.content === this.content;
      }
    }

    class DerivedBox extends Box {
      otherContent: string = "?";
      sameAs(other: this): boolean {
        if (other.otherContent === undefined) {
          console.log("Система типов TS небезопасна")
        }
        return other.otherContent === this.otherContent;
      }
    }

    const base = new Box();
    const derived = new DerivedBox();

    function test(x: Box): boolean {
      return x.sameAs(base)
    }

    test(derived) // Печатает: "Система типов TS небезопасна"
\end{minted}

Единственное значение в TypeScript, которое типизируется this-типом~--- это сам \mintinline{typescript}|this|.

\subsection{Python}

Python~\cite{sanner1999python} --- изначально динамически типизированный язык программирования, в который последовательно добавляются возможности статической типизации.
В том числе в версию языка 3.11 были введены Self-типы\footnote{\url{https://peps.python.org/pep-0673/}\label{foot:self-pep}}.

Также авторы дизайн-предложения Self-типов для Python приводят\footref{foot:self-pep} интересную статистику, согласно которой паттерн типового параметра с рекурсивным ограничением (отчасти заменяемый Self-типами, как мы увидели выше в разделе~\ref{subsubsec:recursive-generics}) встречается в количестве 40\% случаев от использования других популярных типов~--- \mintinline{Python}|dict| и \mintinline{Python}|Callable|.

Стратегия реализации Self-типов в Python заключается в превращении их обратно в \mintinline{Python}|TypeVar| с рекурсивным ограничением\footref{foot:self-pep}.

Аналогично TypeScript Self-типы в Python небезопасны.

\subsection{Java Manifold}

Плагин Manifold к компилятору Java позволяет\footnote{\url{https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext\#the-self-type-with-self}} проаннотировать тип аннотацией \mintinline{Java}|@Self|.
Проаннотированный тип играет роль bound'а (опр.~\ref{def:bound}) Self-типа.

В простой исходящей позиции аннотация \mintinline{Java}|@Self| позволяет обойтись без abstract override методов (см.~\ref{subsubsec:abstract-override}) и дополнительных приведений типов.

\begin{minted}{java}
    class VehicleBuilder {
        /* ... */
        public @Self VehicleBuilder withWheels(int wheels) {
            _wheels = wheels;
            return this;
        }
    }

    class AirplaneBuilder extends VehicleBuilder {
        /* ... */
    }

     Airplane airplane = new AirplaneBuilder()
        .withWheels(2) // Возвращает AirplaneBuilder
        .withWings(1)
\end{minted}

Во входящей позиции тоже можно использовать аннотацию \mintinline{Java}|@Self|.
Это позволяет ввести некоторые дополнительные типовые ограничения.

\begin{minted}{java}
    class A {
        public boolean equals(@Self Object obj) {
            /* ... */
        }
    }

    A a = new A();
    a.equals("строчка вместо объекта типа A"); // Ошибка компиляции
\end{minted}

Однако эти ограничения легко обойти.
Так, следующий код уже не отвергается системой типов.
Поэтому классическая проверка \mintinline{java}|isinstance| в методе \texttt{equals} всё ещё необходима.

\begin{minted}{java}
    Object obj = a;
    obj.equals("строчка вместо объекта типа A");
\end{minted}

\mintinline{Java}|@Self| можно безопасно использовать и в исходящей ковариантной позиции, например, для реализации рекурсивной структуры данных.
Однако для входящей позиции всё ещё требуется проверка времени исполнения.

\begin{minted}{java}
    public class Node {
        private List<Node> children;

        public List<@Self Node> getChildren() {
            return children;
        }

        public void addChild(@Self Node child) {
            checkAssignable(this, child); // Необходима проверка
            children.add(child);
        }
    }

    public class MyNode extends Node {
        /* ... */
    }

    MyNode myNode = findMyNode();
    List<MyNode> = myNode.getChildren();
\end{minted}

Manifold предоставляет возможность писать функции-расширения в Java, и в связи с этим, \mintinline{Java}|@Self| может ссылаться на тип ресивера функции-расширения.

\begin{minted}{java}
    public static <K,V> @Self Map<K,V> add(
            @This Map<K,V> thiz, K key, V value) {
        thiz.put(key, value);
        return thiz;
    }

    HashMap<String, String> map = new HashMap<>()
        .add("nick", "grouper")
        .add("miles", "amberjack");
\end{minted}

\subsection{Swift}

Язык Swift имеет

TODO % TODO

\subsection{Java Core}

methods precisely because their type systems
do not support explicit recursive types, which lead to a mismatch between subclassing and subtyping. This
mismatch means that an expression of a subclass may not always be usable in a context where an expression
of a superclass is expected, which is not intuitive in an object-oriented setting.

even in the presence of negative occurrences of type
recursion variables by distinguishing object types from existential object types.

recursive types break a valuable property subtyping-by-
subclassing (or subtyping-by-inheritance) of object-oriented languages
William R. Cook, Walter Hill, and Peter S. Canning. 1990. Inheritance is not subtyping. In Proceedings of

less precise “declared inexact types” rather than precise “runtime
exact types”?

TODO % TODO

\cite{ryu2016thistype}



\subsection{Языки без наследования}

В языках без наследования и с поддержкой специального полиморфизма через классы типов или трейты Self-типы присутствуют как ссылки на тип, для которого реализуется тот или иной класс типов.

Для примера рассмотрим аналог Self-типов в языке Haskell.


\begin{minted}{haskell}
    class Show #\framebox{a}# where
      show :: #\framebox{a}# -> String

    data Data = Data Int

    instance Show #\framebox{Data}# where
      show :: #\framebox{Data}# -> String
      show (Data x) = "Data(" <> show x <> ")"

    concatenate :: Show a => a -> a -> String
    concatenate x y = show x <> ", " <> show y
\end{minted}

TODO % TODO
