\section{Теория наследования и рекурсивных типов}


%\subsection{Формализация Self-типов} \label{subsec:formalizaton}
%
%В этом разделе мы формализуем понятия подтипизации, объекта, наследования и Self-типов.
%Это позволит нам увидеть причины потенциального нарушения безопасности системы типов (опр.~\ref{def:sound}) при добавлении Self-типов.
%А так же даст идеи по сохранению безопасности.
%
%\begin{definition}
%    \label{def:sound}
%    \term{Безопасная (sound) система типов} --- всякая программа без приведений типов, в которой во время исполнения может возникнуть ошибка типизации, отвергается безопасной статической проверкой типов.
%\end{definition}
%
%\subsubsection{Записи в $\lambda$-исчислении} \label{subsubsec:records}
%
%Возьмём классическое просто типизированное лямбда-исчисление (STLC~\cite{pierce2002types}) и расширим его сперва записями.
%
%\term{Терм записи} имеет вид \[\{x_1 = v_1,\ldots,x_n = v_n\}\] где $x_i$~--- идентификаторы полей, а $v_i$~--- термы, значения полей.
%
%\term{Терм доступа к полю} имеет вид $t.x_i$, где $t$~--- терм, а $x_i$~--- идентификатор поля, к которому производится доступ.
%
%\term{Тип терма записи имеет вид} \[\{x_1 : \sigma_1,\ldots,x_n : \sigma_n\}\] где $x_i$~--- идентификаторы полей, а $\sigma_i$~--- типы значений полей.
%
%\term{Правило подтипизации для типов записей} записывается следующим образом.
%\[
%    %! suppress = EscapeAmpersand
%    \infer{
%        \{x_1 : \sigma_1, \ldots, x_k : \sigma_k, \ldots, x_n : \sigma_n\}
%        <:
%        \{x_1 : \tau_1, \ldots, x_k : \tau_n\}
%    }{\sigma_1 <: \tau_1 & \ldots & \sigma_k <: \tau_k}
%\]
%
%Введём \term{операцию комбинирования записей --- with} и правило типизации для неё.
%
%\[
%    %! suppress = EscapeAmpersand
%    \infer{
%        e_1 ~\mathbf{with}~ e_2 : \{x_1 = \sigma_1, \ldots, x_n = \sigma_n\}
%    }{
%        e_1 : \{x_1 : \sigma_1, \ldots, x_j : \sigma_j, x_{j + 1} : \tau_{1}, \ldots, x_k : \tau_{k - j}\}
%        &
%        e_2 : \{x_j : \sigma_{j + 1}, \ldots, x_n : \sigma_n\}
%        &
%        k \le n
%    }
%\]
%
%\subsubsection{Рекурсивные типы} \label{subsubsec:recursive-types}
%
%Для записи \term{рекурсивного типа}, заданного как $T = F[T]$\footnote{Запись $F[T]$ означает, что тип $T$ входит в запись типа $F$.}, будем использовать следующую нотацию $\mu t\ldotp F[t]$.
%Эта запись эквивалентна бесконечной экспансии, определяемой через шаг развёртки:
%\[\mu t\ldotp F[T] = F[\mu t\ldotp F[T]]\]
%
%Один рекурсивный тип является подтипом другого рекурсивного типа, если их бесконечные экспансии находятся в этом отношении:
%\begin{equation}
%    \label{eq:recursive-subtyping}
%    \infer{
%        \Gamma \vdash \mu s\ldotp \sigma[s] <: \mu t\ldotp \tau[t]
%    }{
%        \Gamma, s <: t \vdash \sigma[s] <: \tau[t]
%    }
%\end{equation}
%
%\subsubsection{Объекты, типы и наследование}
%
%Определим \term{объект} как неподвижную точку функции $P$ вида:
%\[
%    P = \lambda self \ldotp \{m_1 = e_1[self], \ldots, m_n = e_n[self]\}
%\]
%где $m_i$~--- идентификаторы методов объекта, а $e_i$~--- их тела, которые могут содержать $self$ как свободную переменную.
%
%Тогда \term{объект наследник} $C$ будет образовываться комбинированием объекта $P$ с новыми методами:
%\[
%    C = \lambda self \ldotp P~self~\mathbf{with}~\{m_1' = e_1'[self], \ldots, m_k' = e_k'[self]\}
%\]
%
%\term{Типом объекта} будет тип записи, абстрагированный с помощью $\mu$-нотации по рекурсивным вхождениям типа объекта в типы методов.
%
%Для примера рассмотрим объект, представляющий собой точку в одномерном пространстве.
%Он содержит координату точки и метод проверки на равенство двух точек с одинаковым типом.
%\begin{align*}
%    FIX~ \lambda self \ldotp \{ &x = 5, eq = \lambda p \ldotp self.x \equiv p.x \}
%    :
%    \mu t \ldotp \{ x : int, eq : t \to bool \}
%\end{align*}
%
%Зададим объект точки, у которого помимо перечисленных методов будет, например, метод проверки нахождения точки в начале координат.
%Тип такого объекта будет следующим:
%\[
%    \mu t \ldotp \{ x : int, eq : t \to bool, isZero : bool \}
%\]
%
%Однако нетрудно видеть, что второй объект является наследником первого, но не является его подтипом~\cite{cook1989inheritance}.
%Это связано с тем, что в методе $eq$ рекурсивный тип присутствует в контравариантной позиции (слева от функциональной стрелки), а значит, его тип во втором объекте будет супертипом типа $eq$ в первом объекте, а не подтипом, как того требует правило~\eqref{eq:recursive-subtyping}.
%
%Таким образом, рекурсивный тип (Self-тип) безопасно использовать только в ковариантных позициях декларациях методов класса (опр.~\ref{def:type-position-sign}).
%Поэтому в языках с наследованием требуется предпринимать специальные меры по обеспечению безопасности системы типов, так как наследник как правило автоматически считается подтипом.
%Заметим, что для языков без наследования (таких как Rust, Haskell и д.т.) обозначенная проблема не актуальна.


%\section{Анализ существующих реализаций Self-типов}
%
%Как было показано выше, Self-типы с одной стороны имеют множество приложений, с другой~--- эмулируются в коде нетривиальным образом.
%Поэтому не удивительно, что во многих языках Self-типы уже реализованы.
%
%Основной задачей, решаемой в следующей главе (\ref{sec:integration}), является максимизация возможностей, предоставляемых Self-типами, при сохранении безопасности системы типов (опр.~\ref{def:sound}) языка Kotlin.
%Поэтому мы рассмотрим несколько объектно-ориентированных языков с Self-типами и будем в первую очередь обращать внимание на значения Self-типа, позиции, в которых тот или иной язык позволяет использовать Self-типы, а так же на меры, предпринимаемые для сохранения безопасности системы типов.
%
%
%\subsection{Формальные решения для рекурсивных типов} \label{subsec:formal-solutions}
%
%Ранее в разделе~\ref{subsec:formalizaton} мы рассмотрели формализацию Self-типов как рекурсивных типов.
%Исследователи предлагают множество способов их включения в языки с сохранением безопасности~\cite{bruce1997increasing, burstein1998rupiah, cook1989inheritance, ryu2016thistype, saito2009matching}.
%
%
%
%TODO % TODO
%
%
%\subsection{TypeScript}
%
%В языке TypeScript~\cite{bierman2014understanding} Self-типы присутствуют под названием <<this-типы>>\footnote{\url{https://www.typescriptlang.org/docs/handbook/2/classes.html\#this-types}}.
%Они действуют так же, как было рассмотрено выше --- this-тип материализуется в конкретный тип ресивера при вызове метода.
%
%Однако разработчики TypeScript не ставят задачи поддержки безопасности системы типов языка и this-типы можно использовать в произвольной позиции.
%Поэтому нетрудно написать код, например, с this-типом в контравариантной позиции, который проходит проверку типов, но при этом получающий без явных приведений типов значение \mintinline{typescript}|undefined|.
%
%\begin{minted}{typescript}
%    class Box {
%      content: string = "";
%      sameAs(other: this): boolean {
%        return other.content === this.content;
%      }
%    }
%
%    class DerivedBox extends Box {
%      otherContent: string = "?";
%      sameAs(other: this): boolean {
%        if (other.otherContent === undefined) {
%          console.log("Система типов TS небезопасна")
%        }
%        return other.otherContent === this.otherContent;
%      }
%    }
%
%    const base = new Box();
%    const derived = new DerivedBox();
%
%    function test(x: Box): boolean {
%      return x.sameAs(base)
%    }
%
%    test(derived) // Печатает: "Система типов TS небезопасна"
%\end{minted}
%
%Единственное значение в TypeScript, которое типизируется this-типом~--- это сам \mintinline{typescript}|this|.
%
%
%\subsection{Python}
%
%Python~\cite{sanner1999python} --- изначально динамически типизированный язык программирования, в который последовательно добавляются возможности статической типизации.
%В том числе в версию языка 3.11 были введены Self-типы\footnote{\url{https://peps.python.org/pep-0673/}\label{foot:self-pep}}.
%
%Также авторы дизайн-предложения Self-типов для Python приводят\footref{foot:self-pep} интересную статистику, согласно которой паттерн типового параметра с рекурсивным ограничением (отчасти заменяемый Self-типами, как мы увидели выше в разделе~\ref{subsubsec:recursive-generics}) встречается в количестве 40\% случаев от использования других популярных типов~--- \mintinline{Python}|dict| и \mintinline{Python}|Callable|.
%
%Стратегия реализации Self-типов в Python заключается в превращении их обратно в \mintinline{Python}|TypeVar| с рекурсивным ограничением\footref{foot:self-pep}.
%
%Аналогично TypeScript Self-типы в Python небезопасны.
%
%
%\subsection{Java Manifold}
%
%Плагин Manifold к компилятору Java позволяет\footnote{\url{https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext\#the-self-type-with-self}} проаннотировать тип аннотацией \mintinline{Java}|@Self|.
%Проаннотированный тип играет роль bound'а (опр.~\ref{def:bound}) Self-типа.
%
%В простой исходящей позиции аннотация \mintinline{Java}|@Self| позволяет обойтись без abstract override методов (см.~\ref{subsubsec:abstract-override}) и дополнительных приведений типов.
%
%\begin{minted}{java}
%    class VehicleBuilder {
%        /* ... */
%        public @Self VehicleBuilder withWheels(int wheels) {
%            _wheels = wheels;
%            return this;
%        }
%    }
%
%    class AirplaneBuilder extends VehicleBuilder {
%        /* ... */
%    }
%
%     Airplane airplane = new AirplaneBuilder()
%        .withWheels(2) // Возвращает AirplaneBuilder
%        .withWings(1)
%\end{minted}
%
%Во входящей позиции тоже можно использовать аннотацию \mintinline{Java}|@Self|.
%Это позволяет ввести некоторые дополнительные типовые ограничения.
%
%\begin{minted}{java}
%    class A {
%        public boolean equals(@Self Object obj) {
%            /* ... */
%        }
%    }
%
%    A a = new A();
%    a.equals("строчка вместо объекта типа A"); // Ошибка компиляции
%\end{minted}
%
%Однако эти ограничения легко обойти.
%Так, следующий код уже не отвергается системой типов.
%Поэтому классическая проверка \mintinline{java}|isinstance| в методе \texttt{equals} всё ещё необходима.
%
%\begin{minted}{java}
%    Object obj = a;
%    obj.equals("строчка вместо объекта типа A");
%\end{minted}
%
%\mintinline{Java}|@Self| можно безопасно использовать и в исходящей ковариантной позиции, например, для реализации рекурсивной структуры данных.
%Однако для входящей позиции всё ещё требуется проверка времени исполнения.
%
%\begin{minted}{java}
%    public class Node {
%        private List<Node> children;
%
%        public List<@Self Node> getChildren() {
%            return children;
%        }
%
%        public void addChild(@Self Node child) {
%            checkAssignable(this, child); // Необходима проверка
%            children.add(child);
%        }
%    }
%
%    public class MyNode extends Node {
%        /* ... */
%    }
%
%    MyNode myNode = findMyNode();
%    List<MyNode> = myNode.getChildren();
%\end{minted}
%
%Manifold предоставляет возможность писать функции-расширения в Java, и в связи с этим, \mintinline{Java}|@Self| может ссылаться на тип ресивера функции-расширения.
%
%\begin{minted}{java}
%    public static <K,V> @Self Map<K,V> add(
%            @This Map<K,V> thiz, K key, V value) {
%        thiz.put(key, value);
%        return thiz;
%    }
%
%    HashMap<String, String> map = new HashMap<>()
%        .add("nick", "grouper")
%        .add("miles", "amberjack");
%\end{minted}
%
%
%\subsection{Swift}
%
%Язык Swift имеет
%
%TODO % TODO
%
%
%\subsection{Java Core}
%
%methods precisely because their type systems
%do not support explicit recursive types, which lead to a mismatch between subclassing and subtyping. This
%mismatch means that an expression of a subclass may not always be usable in a context where an expression
%of a superclass is expected, which is not intuitive in an object-oriented setting.
%
%even in the presence of negative occurrences of type
%recursion variables by distinguishing object types from existential object types.
%
%recursive types break a valuable property subtyping-by-
%subclassing (or subtyping-by-inheritance) of object-oriented languages
%William R. Cook, Walter Hill, and Peter S. Canning. 1990. Inheritance is not subtyping. In Proceedings of
%
%less precise “declared inexact types” rather than precise “runtime
%exact types”?
%
%TODO % TODO
%
%\cite{ryu2016thistype}
