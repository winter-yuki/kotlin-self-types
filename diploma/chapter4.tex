\section{Интеграция Self-типов в типовую систему языка Kotlin} \label{sec:integration}

Ранее в главе~\ref{sec:theory} были рассмотрены соображения, указывающие на потенциальную небезопасность неаккуратной реализации Self-типов.
Далее в главе~\ref{sec:impls} были приведены различные существующие решения по безопасному внедрению Self-типов в языки.
И теперь мы готовы к тому, чтобы интегрировать Self-типы в Kotlin, учитывая его специфику, и используя заведомо безопасные практики.

Ключевой задачей является сохранение безопасности системы типов вместе с поддержкой наибольшего количества полезных приложений Self-типов, описанных ранее в~\ref{subsec:applications}.
Так, сначала будут рассмотрены различные аспекты интеграции Self-типов в типовую систему языка Kotlin, а так же предложены решения на основании опыта других языков.
И наконец, будет описана экспериментальная реализация Self-типов в компиляторе kotlinc.


\subsection{Синтаксис Self-типов} \label{subsec:syntax}

Чтобы добавить какой-либо синтаксис в язык, нужно сперва тщательно убедиться, что обратная совместимость исходных кодов не будет нарушена.
Если же нарушение неизбежно, то разработать политику по миграции кодовых баз пользователей на новые версии языка.
Подобные исследования не являются задачей данной работы.
Поэтому мы будем вводить синтаксические конструкции вольным образом по необходимости.
Так, в первую очередь будем читать, что идентификатор \texttt{Self} введён как ключевое слово языка.


\subsection{Граница Self-типа} \label{subsec:bound}

\begin{definition}
    \label{def:bound}
    \term{Границей Self-типа} назовём наиболее общий тип ресивера, на котором может быть вызван соответствующий метод.
\end{definition}

Границы будут помогать нам далее различать, откуда пришел тот или иной Self-тип.
Чтобы понять, например, является ли Self-тип подтипом другого типа (раздел~\ref{subsec:self-subtyping}).
Во введённой ранее теории той же цели служила структура типа записи вместе с правилом~\eqref{eq:record-subtype}.

Граница Self-типа совпадает с типом ресивера текущей декларации метода.
В примере ниже для \mintinline[escapeinside=??]{kotlin}|?\framebox{Self}?| границей является \mintinline{kotlin}|Base|, обозначение $Self(Base)$:

\begin{minted}{kotlin}
    interface Base {
        fun base(): #\framebox{Self}# = #\framebox{this}#
    }

    class Defived : Base {
        fun derived() { /* ... */ }
    }

    fun test(d: Derived) = d.base() /* : #\framebox{Derived}# */ .derived()
\end{minted}

Если ближайший ресивер~--- extension-ресивер, то он становится границей.
Границей всегда является not-null тип (см.~\ref{subsec:kotlin-typesystem}) для удобства дальнейших рассуждений.
Так, в следующем примере границей Self-типа в декларации \texttt{dispatch} является \texttt{C}, \texttt{extension}~--- \texttt{B}, \texttt{topLevel}~--- \texttt{B}, и в \texttt{nullable}~--- тоже \texttt{B}.

\begin{minted}{kotlin}
    class C {
        fun dispatch(): Self /* (C) */ = this
        fun B.extension(): Self /* (B) */ = this
    }

    fun B.topLevel(): Self /* (B) */ = this
    fun B?.nullable(): Self? /* (B) */ = this // : Self(B)?
\end{minted}

\subsubsection{Указание границы Self-типа}

Естественным образом возникает вопрос, можно ли вручную задавать границу Self-типа.
Например, в синтаксисе меток, аналогичным меткам ссылок на ресиверы (\mintinline{kotlin}|this@functionOrClass|).

\begin{minted}{kotlin}
    class C {
        fun A.foo(): Self@C /* (C) */ {
            fun B.bar(): Self@C /* (C) */ = this@C
            fun B.baz(): Self@foo /* (A) */ = this@foo
            return B().bar() /* : Self(C) */
        }

        fun bar(c: C): С {
            with(c) {
                return A().foo() /* : C */
            }
        }
    }
\end{minted}

Другим применением меток Self-типа может быть использование их во вложенных классах:

\begin{minted}{kotlin}
    class Outer {
        inner class Inner {
            fun getOuter(): Self@Outer = this@Outer
        }

        fun out(): Out<Self> = object : Out<Self> {
            override fun produce(): Self@Outer = this@Outer
        }
    }
\end{minted}

Однако не известны приложения явного указания границы, кроме случая функции \texttt{out} из примера в случае поддержания Self-типов в позиции типового аргумента (будет рассмотрено далее в~\ref{subsec:self-positions}).

\subsubsection{Скоуп Self-типа}

После смены типа ресивера $C$ внутри класса, \mintinline{kotlin}|this|, на $Self(C)$ должна быть возможность продолжать вызывать на нём все те же методы, что и раньше.
Поэтому скоуп Self-типа должен, хотя бы за вычетом методов с Self-типами ($selfs(C)$), совпадать со скоупом его границы:
\begin{equation*}
    scope(C) \setminus selfs(C) = scope(Self(C)) \setminus selfs(C)
\end{equation*}


\subsection{Материализация Self-типа} \label{subsec:materialization}

Чтобы воспользоваться значениями и методами, которые содержатся в записи с рекурсивным типом (см.~\ref{subsec:recursive-types}), требуется применить правило развёртки рекурсивного типа~\eqref{eq:unfold} и~\eqref{eq:unfold-ex}, как было показано на примере~\eqref{eq:unfold-example}.

Если мы позволим вызывать методы с Self-типами без каких-либо предварительных преобразований, это приведёт к небезопасности системы типов, так как Self-тип (связанный $\mu$-нотацией типовой параметр в нашей аналогии~\ref{subsec:recursive-types}) окажется вне своего контекста и будет обозначать тип времени исполнения ресивера уже другого объекта:

\begin{minted}{kotlin}
    abstract class A {
        fun self(): Self = this // Имеет Self-тип по определению
        fun unsafe(a: A): Self = a.self() // Пусть получили Self-тип
    }

    class B : A() {
        fun bOnly() {}
    }

    fun test(a: A, b: B) {
        b.unsafe(a) /* скоуп типа B */ .bOnly() // #\err#
    }
\end{minted}

Поэтому, чтобы пользоваться методами с Self-типом нам требуется ввести аналог правила развёртки.

\begin{definition}
    \label{def:materialization}
    \term{Материализация Self-типа} --- подмена Self-типа в сигнатуре метода на тип ресивера в скоупе типа этого ресивера (опр.~\ref{def:type-scope}).
\end{definition}

Материализация $Self(A)$ может происходить в произвольного подтипа типа границы $A$, так для примера выше $Self(A)$ материализуется в сам $A$ в его скоупе:
\[(self: A.() \to \framebox{A}) \in scope(A)\]
И если $A \bcancel{<:} Self(A)$, этот код будет отвергаться системой типов, так как $a.self() : A$ (аккуратно отношение подтипизации для Self-типов будет введено позже в разделе~\ref{subsec:self-subtyping}).

Заметим, что в скоупе типа ресивера, \mintinline{kotlin}|this|, (то есть Self-типа, например, $Self(B)$), Self-тип декларации ($Self(A)$) материализуется в $Self(B)$.
Так как Self-тип не покидает контекста того же объекта, его значение безопасно использовать в позициях, где ожидается Self-тип.
В то же время поскольку материализация может уточнить границу, следующий корректный код будет типизироваться в любом случае вне зависимости от отношения подтипизации между Self-типами с различными границами:

\begin{minted}{kotlin}
    abstract class A {
        fun self(): Self = this
        fun safeA(): Self /* (A) */ = this.self() // : Self(A)
    }

    class B : A() {
        fun bOnly() {}
        fun safeB(): Self /* (B) */ = this.self() // : Self(B)
    }

    fun test(b: B) {
        b.safeA().bOnly()
        b.safeB().bOnly()
    }
\end{minted}

Введённое правило материализации можно сопоставить правилу развёртки следующим образом.
Будем считать Self-тип аналогом точного типа (так как он ссылается на рекурсивный тип записи), тогда развёртка для него выполняется по правилу~\eqref{eq:unfold}, и вместо рекурсивной ссылки $t$ в типе записи появляется тот же точный тип, то есть Self-тип.
В то же время будем считать обычный статически известный тип $C$ экзистенциальным типом $\exists X <: C \ldotp X$ (см.~\ref{subsec:existentials}), поэтому для него будет работать правило~\eqref{eq:unfold-ex}, подставляющее экзистенциальный тип вместо рекурсивной ссылки.


\subsection{Подтипизация Self-типов} \label{subsec:self-subtyping}

Ранее в~\ref{subsec:materialization} мы увидели, некоторые свойства относительно подтипизации, которыми должен обладать Self-тип.
Приведём остальные (отношение $\sim$ задаёт эквивалентность типов: $A \sim B \iff A <: B \land B <: A$).

\begin{enumerate}
    \item \label{itm:self-equals} $B <: A \Rightarrow Self(B) \sim Self(A)$ для возможности переопределения методов с Self-типами;
    \item \label{itm:this-subtype} $B <: A \Rightarrow Self(B) <: A$, чтобы код с \mintinline{kotlin}|this| оставался типизируемым;
    \item \label{itm:any-nothing} $Nothing <: Self(A)$ и $Self(A) <: Any$;
    \item \label{itm:no-subtypes} $B \bcancel{<:} Self(A)$, если $B$ не подходит под правила (\ref{itm:self-equals}) и (\ref{itm:any-nothing}).
\end{enumerate}

Правило (\ref{itm:no-subtypes}) не позволяет использовать в позиции, где ожидается Self-тип, посторонний объект, отличный от ресивера, чем обеспечивает безопасность системы типов.

Приведённые правила стандартным образом дополняются для работы с nullable значениями:
$B <: A \Rightarrow B <: A?, B? <: A?$.

Осталось определить правило определения ближайшего общего супертипа ($CST$, common supertype), оно следует из введённого отношения подтипизации (случаи nullable типов рассматриваются аналогично):
\begin{enumerate}
    \item $CST(Self(C1), Self(C2)) \sim Self(CST(C1, C2))$;
    \item $CST(Self(B), A) \sim CST(B, A)$.
\end{enumerate}


\subsection{Создание новых объектов Self-типа} \label{subsec:new}

Ранее мы подразумевали, что существует лишь одно значение Self-типа~--- \mintinline{kotlin}|this| (или \mintinline{swift}|self|, как его ещё называют).
Однако для многих важных приложений, например персистентных коллекций, требуется уметь создавать новые объекты Self-типа.
Оказывается, во многих случаях это делать небезопасно.
Так, присвоение Self-типа новым объектам открытых классов\footnote{\term{Открытый класс} --- класс, которой можно использовать как базовый при объявлении других классов.} и в открытых классах недопустимо:

\begin{minted}{kotlin}
    open class A {
        // Создание объекта открытого класса
        fun newOfOpenA(): Self = A()
        // Создание объекта в открытом классе
        fun newOtherQ(): Self = Q()
    }

    class Q : A() { fun qOnly() {} }
    class P : A() { fun pOnly() {} }

    fun test(q: Q, p: P) {
        q.newOfOpenA() // скоуп типа Q для A
         .qOnly()      // #\err#
        p.newOther()   // скоуп типа P для Q
         .pOnly()      // #\err#
    }
\end{minted}

Проблемы возникают из-за того, что при материализации Self-тип может стать произвольным наследником своей границы (или другим Self-типом с границей-наследником).
Поэтому, чтобы мочь новый объект \texttt{C(..)} безопасно протипизировать Self-тип необходимо добиться, чтобы его тип всегда был подтипом типа ресивера времени исполнения\footnote{Пусть \mintinline{kotlin}|this@decl| --- ссылка на ресивер ближайшей декларации.\label{foot:this-decl}}:
\begin{minted}{kotlin}
    C::class isSubtypeOf this@decl.getClass()
\end{minted}

Среди промышленных языков, описанных в главе~\ref{sec:impls}, ни один не поддерживает какие-либо значения Self-типа, кроме ссылки на ресивер (\mintinline{kotlin}|this| или \mintinline{swift}|self|).
Однако в литературе (см.~\ref{subsec:academic-approaches}) приводятся ряд способов безопасно протипизировать новое значение Self-типом.

Первый способ --- ненаследуемые методы~\cite{saito2009matching}.
\term{Ненаследуемый метод}~--- это метод, который должен быть переопределён в каждом наследнике.
Утверждается, что в таком методе безопасно типизировать новые объекты объемлющего класса Self-типом.
Действительно, поскольку метод должен быть переопределён, виртуальная диспетчеризация всегда приводит к вызову метода наследника, создающему объект того же типа времени исполнения, на котором метод был вызван.
Поэтому необходимое условие типизации нового значения Self-типом, данное выше, заведомо выполняется.

Второй способ~--- виртуальные конструкторы~\cite{ryu2016thistype}.
\term{Виртуальный конструктор} --- это метод, возвращающий Self-тип, который вместо явного вызова конструктора класса (что может приводить к небезопасности, описанной выше) использует конструкцию вида \mintinline{java}|new This()|, создающую объект объект нужного наследника.
Этот подход, в отличие от ненаследуемых методов, позволяет наследовать реализацию виртуального конструктора в наследнике и переиспользовать его код.
Однако для этого требуется наложить большое количество специфических правил.
А именно: виртуальный конструктор может быть только один; если виртуальный конструктор в наследнике имеет отличные от виртуального конструктора базового класса параметры, то он скрывает виртуальный конструктор базового класса, и все методы, вызывающие его, должны быть переопределены для нового конструктора; и др.

Нетрудно видеть, что оба подхода требуют довольно масштабных нововведений в языке в виде нового вида методов и сложным образом организованных правил для них.
Это проблематично как с точки зрения реализации в компиляторе, так и дизайна языка, и, судя по всему, несоразмерно пользе и количеству сценариев использования.
Поэтому мы приведём упрощённое правило, позволяющее типизировать новые объекты Self-типом, которое, тем не менее, не закрывает возможность реализации обоих подходов в дальнейшем.

Для того чтобы протипизировать создание нового объекта \texttt{C(..)} Self-типом, необходимо выполнение следующих условий:

\begin{enumerate}
    \item \label{itm:new-final} Класс \texttt{C} должен быть финальным\footnote{\term{Финальный класс} --- класс, для которого нельзя объявлять наследников.};
    \item \label{itm:new-this} Тип \mintinline{kotlin}|this@decl|\footref{foot:this-decl} либо равен \texttt{С}, либо включает \texttt{C} в типе-пересечении (опр.~\ref{def:intersection-types}) после smart-cast (опр.~\ref{def:start-cast});
    \item \label{itm:new-module} Тип \texttt{C} объявлен в том же модуле, в котором создаётся объект.
\end{enumerate}

Правила~(\ref{itm:new-final}) и~(\ref{itm:new-this}) гарантируют выполнения необходимого условия безопасности типизации нового значения Self-типом.
Действительно, так как \texttt{C} совпадает со статическим типом ресивера (\ref{itm:new-this}) и у этого типа не может быть подтипов из-за финальности (\ref{itm:new-final}), то \texttt{C} всегда равен типу времени исполнения ресивера, а значит тривиально является подтипом самого себя.

То, что \texttt{C} может включаться в статический тип пересечения (\ref{itm:new-this}), позволяет создавать новые объекты Self-типа не только в последнем классе иерархии наследования (однако это ограничение всё ещё делает предложенный метод менее мощным, чем академические, описанные выше, где создавать новые объекты Self-типа позволено на произвольном уровне иерархии наследования):

\begin{minted}[escapeinside=??]{kotlin}
    sealed interface Data {
        class One(val a: Int) : Data
        class Two(val a: Int, val b: Int) : Data

        fun update(a: Int): Self =
            when (this) {
                is One -> ?\colorbox{green}{One(a)}?    // : Self(One)
                is Two -> ?\colorbox{green}{Two(a, b)}? // : Self(Two)
            } // : Self(Data) по CST
    }
\end{minted}

Последнее ограничение (\ref{itm:new-module}) предотвращает возникновение несовместимости исходных кодов при открытии класса.
Это важно, так как до сих пор (до Kotlin версии 1.8.21) открытие класса не может нарушить обратной совместимости.
Рассмотрим следующий пример, в нём открытие класса \texttt{One} из примера выше делает код некомпилируемым, если декларация \texttt{One} находится в другом модуле~--- это нарушение совместимости исходных кодов:

\begin{minted}{kotlin}
    operator fun Data.plus(d: Int): Self =
        when (this) {
            is One -> #\colorbox{green}{One(a + d)}# // : Self, пока One финальный
            is Two -> #\colorbox{green}{Two(a + d, b + d)}#
        }
\end{minted}


\subsection{Позиции Self-типа} \label{subsec:self-positions}

Как мы поняли ранее (см.~\ref{subsec:rec-subtyping}), не во всех позициях безопасно использовать Self-типы.
Так, в ковариантных позициях Self-типы можно использовать без опасений, языки с безопасными системами этого, как правило, всё равно не позволяют, кроме как в простой исходящей позиции, ввиду отсутствия поддержки вариантности, как, например, Swift (см.~\ref{subsec:swift}).
В то же время Self-типы в контравариантных позициях мешают наследнику быть подтипом~\cite{cook1989inheritance}, и языки вынуждены предпринимать те или иные специальные меры.

Однако если Self-тип относится не к dispatch ресиверу (опр.~\ref{def:dispatch-receivers}), а к extension ресиверу (опр~\ref{def:extension-receivers}), то проблемы наследования становятся не актуальны.
Этот случай будет рассмотрен в~\ref{subsubsec:extension-position}.

\subsubsection{Ковариантные позиции Self-типа}

Поскольку Kotlin поддерживает вариантность (\ref{subsubsec:variance}), а так же существует немало приложений у Self-типов в ковариантных позициях (см.~\ref{subsec:applications}), то есть смысл поддержать использование Self-типы в этих позициях.

\subsubsection{Контравариантные позиции Self-типа}

Теперь рассмотрим контравариантные позиции, а именно самый простой случай~--- бинарные методы.
Мы уже ранее приводили пример кода на TypeScript (см.~\ref{subsec:typescript}), который использовал this-тип в контравариантной позиции, что приводило к небезопасности системы типов (возникновению \mintinline{typescript}|undefined| в корректно типизированной программе).
Рассмотрим различные подходы по обеспечению безопасности контравариантной позиции, приведённые в главе~\ref{sec:impls}, применительно к Kotlin и оценим их применимость.

Каждый приведённый подход так или иначе выделяет отдельно методы с Self-типами и накладывает на них особенные ограничения.

\begin{enumerate}
    \item Swift позволяет использовать Self-типы в контравариантных позициях в протоколах, но требует подменять их на конкретный тип класса при реализации протокола этим классом (см.~\ref{subsec:swift}).
    В отличие от Kotlin в Swift нет возможности писать реализации по умолчанию методам в протоколах/интерфейсах, в Kotlin специально для методов с Self-типами это пришлось бы запретить.
    \item Также, как правило, вводится новая вселенная точных типов, на которых можно вызывать методы с Self-типами в контравариантных позициях.
    Что требует довольно масштабных изменений в системе типов языка как с точки зрения дополнительных конструкций, так и новых механизмов вывода точных типов~\cite{ryu2016thistype}.
    \item В противном случае приходится границей Self-типа в контравариантной позиции назначать самый базовой тип (и соответствующий скоуп), метод которого переопределяется данным.
    Однако такой скоуп, как правило, не позволяет написать никакой полезной нетривиальной реализации (как в примере~\ref{subsubsec:algebras}).
\end{enumerate}

Поскольку все решения ограничивают виртуальную диспетчеризацию вызова бинарного метода, имеет смысл полностью от неё отказаться в пользу статической.
Такое решение уже рассматривалось в~\ref{subsubsec:algebras}, где выбор делался в пользу использования контекстных ресиверов языка Kotlin, которые покрывают подобные сценарии использования.
Аналогично для других контравариантных позиций.

Таким образом, поддержка Self-типов, соответствующих dispatch-ресиверам, в контравариантных позициях выглядит нецелесообразной.

\subsubsection{Позиции Self-типа в функциях-расширениях} \label{subsubsec:extension-position}

Поскольку для функций-расширений не актуальны проблемы наследования, Self-тип в них можно использовать в произвольной позиции подобно инвариантному типовому параметру:

\begin{minted}{kotlin}
    fun A.f(x: Self, p: Out<Self>, c: In<Self>): Self {
        c.consume(p.produce()); return x
    }
    // аналогично
    fun <T : A> T.f(x: T, p: Out<T>, c: In<T>): T {
        c.consume(p.produce()); return x
    }
\end{minted}

Границей может быть типовой параметр или инстанциированный типовой конструктор:

\begin{minted}[mathescape]{kotlin}
    fun <T> T.f(x: T, y: Self): Pair<Self, Self> =
        Pair(x /* ошибка: $T \bcancel{<:} Self(T)$ */, y /* ok */)
    fun <T> List<T>.shuffle(): Self { /* ... */ }
\end{minted}

В то же время, как обсуждалось выше (\ref{subsec:bound}), граница всегда not-null тип:

\begin{minted}{kotlin}
    fun A?.f(x: Self): Self? = this?.doSomething(x)
    // аналогично следующему
    fun <T : A> T?.f(x: T): T? = this?.doSomething(x)
\end{minted}


\subsection{Экспериментальная реализация Self-типов в компиляторе kotlinc}

В рамках данной работы была разработана экспериментальная реализация Self-типов в компиляторе kotlinc версии K2.

Компилятор K2 имеет двухчастную архитектуру.
\term{Frontend} занимается семантическим анализом программы, дополняя специальное промежуточное представление программы \term{FIR} (frontend intermediate representation) различной информацией, в том числе происходящей из анализа типов: вывода типов и проверки типизируемости.
\term{Backend} занимается генерацией кода под различные целевые платформы, а так же оптимизациями.
При передаче программы с frontend на backend модель программы, которой пользуется frontend (FIR) преобразуется в модель для backend'а (\term{IR}).

Поскольку целью данной работы является развитие системы типов языка Kotlin, основные изменения были произведены во frontend и в модуле конвертации FIR в IR.

Как уже было сказано выше (\ref{subsec:syntax}), исследование синтаксиса Self-типов не входит в задачи данной работы, поэтому Self-тип введён как ключевое слово языка.
А точнее, при конвертации результата парсинга программы в FIR, вершина дерева, соответствующая типу с именем Self, подменяется на специальную вершину Self-типа.
Для прототипа этого оказывается достаточно.

Далее правила системы типов Kotlin были дополнены для работы с Self-типами описанным выше образом.
А именно: правило проверки подтипизации, вычисления ближайших супертипов типа и вычисления ближайшего общего супертипа двух типов.

Ключевым в реализации является модификация скоупов таким образом, чтобы они производили материализацию Self-типа в тип ресивера.
Скоупы~--- это набор сервисов компилятора, которые производят поиск деклараций, доступных для вызова на конкретном типа (см.~\ref{def:type-scope}).
Чтобы произвести материализацию, требуется генерировать синтетические декларации, в которых вместо Self-типа подставлен тип ресивера.
Это происходит аналогично подстановке типовых параметров дженерик-функций.

И наконец, при преобразовании FIR в IR Self-тип подменяется на его границу, а так же метаинформацию, чтобы сохранить сведение о том, что это изначально был Self-тип (для использования этой декларации в другом Kotlin-модуле, например).
Соответственно из Java Self-типы видны просто как их границы.
