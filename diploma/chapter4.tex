\section{Интеграция Self-типов в типовую систему языка Kotlin} \label{sec:integration}

Ранее в главе~\ref{sec:theory} были рассмотрены соображения, указывающие на потенциальную небезопасность неаккуратной реализации Self-типов.
Далее в главе~\ref{sec:impls} были приведены различные существующие решения по безопасному внедрению Self-типов в языки.
И теперь мы готовы к тому, чтобы интегрировать Self-типы в Kotlin, учитывая его специфику, и используя заведомо безопасные практики.

Ключевой задачей является сохранение безопасности системы типов вместе с поддержкой наибольшего количества полезных приложений Self-типов, описанных ранее в~\ref{subsec:applications}.
Так, сначала будут рассмотрены различные аспекты интеграции Self-типов в типовую систему языка Kotlin, а так же предложены решения на основании опыта других языков.
И наконец, будет описана реализация прототипа Self-типов в компиляторе kotlinc.


\subsection{Синтаксис Self-типов}

Чтобы добавить какой-либо синтаксис в язык, нужно сперва тщательно убедиться, что обратная совместимость исходных кодов не будет нарушена.
Если же нарушение неизбежно, то разработать политику по миграции кодовых баз пользователей на новые версии языка.
Подобные исследования не являются задачей данной работы.
Поэтому мы будем вводить синтаксические конструкции вольным образом по необходимости.
Так, в первую очередь будем читать, что идентификатор \texttt{Self} введён как ключевое слово языка.


\subsection{Граница Self-типа} \label{subsec:bound}

\begin{definition}
    \label{def:bound}
    \term{Границей Self-типа} назовём наиболее общий тип ресивера, на котором может быть вызван соответствующий метод.
\end{definition}

Границы будут помогать нам далее различать, откуда пришел тот или иной Self-тип.
Чтобы понять, например, является ли Self-тип подтипом другого типа.
Во введённой ранее теории той же цели служила структура типа записи вместе с правилом~\eqref{eq:record-subtype}.

\begin{minted}{kotlin}
    interface Base {
        fun base(): #\framebox{Self}# = #\framebox{this}#
    }

    class Defived : Base {
        fun derived() { /* ... */ }
    }

    fun test(d: Derived) = d.base() /* : #\framebox{Derived}# */ .derived()
\end{minted}

Граница Self-типа совпадает с типом ресивера текущей декларации метода.
В примере выше для \mintinline[escapeinside=??]{kotlin}|?\framebox{Self}?| границей является \mintinline{kotlin}|Base|~--- $Self(Base)$).

Если ближайший ресивер~--- extension-ресивер, то он становится границей.
Границей всегда является not-null тип (см.~\ref{subsec:kotlin-typesystem}) для удобства дальнейших рассуждений.
Так, в следующем примере границей Self-типа в декларации \texttt{dispatch} является \texttt{C}, \texttt{extension}~--- \texttt{B}, \texttt{topLevel}~--- \texttt{B}, и в \texttt{nullable}~--- тоже \texttt{B}.

\begin{minted}{kotlin}
    class C {
        fun dispatch(): Self /* (C) */ = this
        fun B.extension(): Self /* (B) */ = this
    }

    fun B.topLevel(): Self /* (B) */ = this
    fun B?.nullable(): Self? /* (B) */ = this // : Self(B)?
\end{minted}

\subsubsection{Указание границы Self-типа}

Естественным образом возникает вопрос, можно ли вручную задавать границу Self-типа.
Например, в синтаксисе меток, аналогичным меткам ссылок на ресиверы (\mintinline{kotlin}|this@functionOrClass|).

\begin{minted}{kotlin}
    class C {
        fun A.foo(): Self@C /* (C) */ {
            fun B.bar(): Self@C /* (C) */ = this@C
            fun B.baz(): Self@foo /* (A) */ = this@foo
            return B().bar() /* : Self(C) */
        }

        fun bar(c: C): Self {
            with(c) {
                return A().foo() /* C */
            }
        }
    }
\end{minted}

Другим применением меток Self-типа может быть использование их во вложенных классах:

\begin{minted}{kotlin}
    class Outer {
        inner class Inner {
            fun getOuter(): Self@Outer = this@Outer
        }

        fun out(): Out<Self> = object : Out<Self> {
            override fun produce(): Self@Outer = this@Outer
        }
    }
\end{minted}

Однако не известны приложения явного указания границы, кроме случая функции \texttt{out} из примера в случае поддержания Self-типов в позиции типового аргумента (будет рассмотрено далее в~\ref{subsec:self-positions}).

\subsubsection{Скоуп Self-типа}

После смены типа ресивера $C$ внутри класса, \mintinline{kotlin}|this|, на $Self(C)$ должна быть возможность продолжать вызывать на нём все те же методы, что и раньше.
Поэтому скоуп Self-типа должен, хотя бы за вычетом методов с Self-типами ($selfs(C)$), совпадать со скоупом его границы:
\begin{equation*}
    scope(C) \setminus selfs(C) = scope(Self(C)) \setminus selfs(C)
\end{equation*}


\subsection{Материализация Self-типа} \label{subsec:materialization}

Чтобы воспользоваться значениями и методами, которые содержатся в записи с рекурсивным типом (см.~\ref{subsec:recursive-types}), требуется воспользоваться правилом развёртки рекурсивного типа~\eqref{eq:unfold} и~\eqref{eq:unfold-ex}, как было показано на примере~\eqref{eq:unfold-example}.

Если мы позволим вызывать методы с Self-типами без каких-либо предварительных преобразований, это приведёт к небезопасности системы типов, так как Self-тип (связанный $\mu$-нотацией типовой параметр в нашей аналогии~\ref{subsec:recursive-types}) окажется вне своего контекста и будет обозначать тип времени исполнения ресивера уже другого класса:

\begin{minted}{kotlin}
    abstract class A {
        fun self(): Self = this // Имеет Self-тип по определению
        fun unsafe(a: A): Self = a.self() // Пусть получили Self-тип
    }

    class B : A() {
        fun bOnly() {}
    }

    fun test(a: A, b: B) {
        b.unsafe(a) /* скоуп типа B */ .bOnly() // #\err#
    }
\end{minted}

Поэтому, чтобы пользоваться методами с Self-типом нам требуется ввести аналог правила развёртки.

\begin{definition}
    \label{def:materialization}
    \term{Материализация Self-типа} --- подмена Self-типа в сигнатуре метода на тип ресивера в скоупе типа этого ресивера (опр.~\ref{def:type-scope}).
    Таким образом, материализация $Self(A)$ может происходить в произвольного подтипа типа границы $A$.
\end{definition}

Таким образом, для примера выше $Self(A)$ материализуется в $A$ в его скоупе:
\[(self: A.() \to \framebox{A}) \in scope(A)\]
И если $A \bcancel{<:} Self(A)$, этот код будет отвергаться системой типов, так как $a.self() : A$ (аккуратно отношение подтипизации для Self-типов будет введено позже в разделе~\ref{subsec:self-subtyping}).

Заметим, что в скоупе типа ресивера, \mintinline{kotlin}|this|, (то есть Self-типа, например, $Self(B)$), Self-тип декларации ($Self(A)$) материализуется в $Self(B)$.
Так как Self-тип не покидает контекста того же объекта, его значение безопасно использовать в позициях, где ожидается Self-тип.
В то же время поскольку материализация может уточнить границу, следующий корректный код будет типизироваться в любом случае вне зависимости от отношения подтипизации между Self-типами с различными границами:

\begin{minted}{kotlin}
    abstract class A {
        fun self(): Self = this
        fun safeA(): Self /* (A) */ = this.self() // : Self(A)
    }

    class B : A() {
        fun bOnly() {}
        fun safeB(): Self /* (B) */ = this.self() // : Self(B)
    }

    fun test(b: B) {
        b.safeA().bOnly()
        b.safeB().bOnly()
    }
\end{minted}

Введённое правило материализации можно сопоставить правилу развёртки следующим образом.
Будем считать Self-тип аналогом точного типа, тогда развёртка для него выполняется по правилу~\eqref{eq:unfold}, и вместо рекурсивной ссылки $t$ появляется тот же точный тип, то есть Self-тип.
В то же время будем считать обычный статически известный тип $C$ экзистенциальным типом $\exists X <: C \ldotp X$ (см.~\ref{subsec:existentials}), поэтому для него будет работать правило~\eqref{eq:unfold-ex}, подставляющее экзистенциальный тип вместо рекурсивной ссылки.

%Скоупы Self-типа $Self(A)$ и его границы $A$ совпадают с точностью до материализации Self-типов:
%\[scope(A) \circeq scope(Self(A))\]


\subsection{Подтипизация Self-типов} \label{subsec:self-subtyping}

Ранее в~\ref{subsec:materialization} мы увидели, некоторые свойства относительно подтипизации, которыми должен обладать Self-тип.
Приведём остальные (отношение $\sim$ задаёт эквивалентность типов: $A \sim B \iff A <: B \land A :> B$).

\begin{enumerate}
    \item \label{itm:covariant-bound} $B <: A \Rightarrow Self(B) \sim Self(A)$ для возможности переопределения методов с Self-типами;
    \item \label{itm:this-subtype} $B <: A \Rightarrow Self(B) <: A$, чтобы код с \mintinline{kotlin}|this| оставался типизируемым;
    \item \label{itm:any-nothing} $Nothing <: Self(A)$ и $Self(A) <: Any$;
    \item \label{itm:no-subtypes} $B \bcancel{<:} Self(A)$, если $B$ не подходит под правила (\ref{itm:covariant-bound}) и (\ref{itm:any-nothing}).
\end{enumerate}

Правило (\ref{itm:no-subtypes}) не позволяет использовать в позиции, где ожидается Self-тип, посторонний объект, отличный от ресивера, чем обеспечивает безопасность системы типов.

Приведённые правила стандартным образом дополняются для работы с nullable значениями:
$B <: A \Rightarrow B <: A?, B? <: A?$.

Осталось определить правило определения ближайшего общего супертипа ($CST$, common supertype), оно следует из введённого отношения подтипизации:
\begin{enumerate}
    \item $CST(Self(C1), Self(C2)) \sim Self(CST(C1, C2))$;
    \item $CST(Self(B), A) \sim CST(B, A)$.
\end{enumerate}


\subsection{Создание новых объектов Self-типа}

Ранее мы подразумевали, что существует лишь одно значение Self-типа~--- \mintinline{kotlin}|this| (или \mintinline{swift}|self|, как его ещё называют).
Однако для многих важных приложений, например персистентных коллекций, требуется уметь создавать новые объекты Self-типа.
Оказывается, во многих случаях это делать небезопасно.
Так, присвоение Self-типа новым объектам открытых классов\footnote{\term{Открытый класс} --- класс, которой можно использовать как базовый при объявлении других классов.} и в открытых классах недопустимо:

\begin{minted}{kotlin}
    open class A {
        // Создание объекта открытого класса
        fun newOfOpenA(): Self = A()
        // Создание объекта в открытом классе
        fun newOtherQ(): Self = Q()
    }

    class Q : A() { fun qOnly() {} }
    class P : A() { fun pOnly() {} }

    fun test(q: Q, p: P) {
        q.newOfOpenA() // скоуп типа Q для A
         .qOnly()      // #\err#
        p.newOther()   // скоуп типа P для Q
         .pOnly()      // #\err#
    }
\end{minted}

Проблемы возникают из-за того, что при материализации Self-тип может стать произвольным наследником своей границы (или другим Self-типом с границей-наследником).
Поэтому, чтобы мочь новому объекту \texttt{C(..)} безопасно присвоить Self-тип необходимо добиться, чтобы его тип всегда был подтипом типа ресивера времени исполнения\footnote{Пусть \mintinline{kotlin}|this@decl| --- ссылка на ресивер ближайшей декларации.}:
\begin{minted}{kotlin}
    C::class isSubtypeOf this@decl.getClass()
\end{minted}

Среди промышленных языков, описанных в главе~\ref{sec:impls}, ни один не поддерживает какие-либо значения Self-типа, кроме ссылки на ресивер (\mintinline{kotlin}|this| или \mintinline{swift}|self|).
Однако в литературе~\ref{subsec:academic-approaches} приводятся ряд способов безопасно протипизировать новое значение Self-типом.

Первый способ --- ненаследуемые методы~\cite{saito2009matching}.
\term{Ненаследуемый метод}~--- это метод, который не может быть унаследован и должен быть переопределён в каждом наследнике.
Утверждается, что в таком методе безопасно типизировать новые объекты объемлющего класса Self-типом.
Действительно, поскольку метод должен быть переопределён,

TODO % TODO


\subsection{Позиции Self-типа} \label{subsec:self-positions}

TODO % TODO


\subsection{Экспериментальная реализация Self-типов в компиляторе kotlinc}

TODO % TODO

TODO % TODO взаимодействие с Java
