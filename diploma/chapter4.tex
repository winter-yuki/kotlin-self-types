\section{Интеграция Self-типов в типовую систему языка Kotlin} \label{sec:integration}

Ранее в главе~\ref{sec:theory} были рассмотрены соображения, указывающие на потенциальную небезопасность неаккуратной реализации Self-типов.
Далее в главе~\ref{sec:impls} были приведены различные существующие решения по безопасному внедрению Self-типов в языки.
И теперь мы готовы к тому, чтобы интегрировать Self-типы в Kotlin, учитывая его специфику, и с использованием безопасных практик.

Ключевой задачей является сохранение безопасности системы типов вместе с поддержкой наибольшего количества полезных приложений Self-типов, описанных ранее в~\ref{subsec:applications}.
Так, сначала будут рассмотрены различные аспекты интеграции Self-типов в типовую систему языка Kotlin, а так же предложены решения на основании опыта других языков.
И наконец, опишем реализацию прототипа Self-типов в компиляторе kotlinc.


\subsection{Основные понятия}

Рассмотрим основные понятия, которые будем использовать в рассуждениях о Self-типах в Kotlin.

\subsubsection{Граница Self-типа}

\begin{definition}
    \label{def:bound}
    Границей Self-типа назовём наиболее общий тип ресивера, на котором может быть вызван соответствующий метод.
\end{definition}

Границы будут помогать нам далее различать, откуда пришел тот или иной Self-тип.
Чтобы понять, например, является ли один Self-тип подтипом другого.
Во введённой ранее теории той же цели служила структура типа записи вместе с правилом~\eqref{eq:record-subtype}.

\begin{minted}{kotlin}
    interface Base {
        fun base(): #\framebox{Self}# = #\framebox{this}#
    }

    class Defived : Base {
        fun derived() { /* ... */ }
    }

    fun test(d: Derived) = d.base() /* : Derived */ .derived()
\end{minted}

Граница Self-типа совпадает с типом ресивера текущей декларации метода.
В примере выше для \mintinline[escapeinside=??]{kotlin}|?\framebox{Self}?| bound'ом является \mintinline{kotlin}|Base| (обозначение \mintinline{kotlin}|Self(Base)|).

Если ближайший ресивер --- extension-ресивер, то он становится границей.
Так, в следующем примере границей Self-типа в декларации \texttt{foo} является \texttt{C}, в декларации \texttt{bar}~--- \texttt{B}, а в декларации \texttt{baz}~--- \texttt{B}.
Заметим, что \texttt{baz} вовсе не имеет dispatch-ресивера.

\begin{minted}{kotlin}
    class C {
        fun foo(): Self /* (C) */ = this
        fun B.bar(): Self /* (B) */ = this
    }

    fun B.baz(): Self /* (B) */ = this
\end{minted}

\subsubsection{Материализация Self-типа}

Чтобы воспользоваться значениями и методами, которые содержатся в записи с рекурсивным типом (см.~\ref{subsec:recursive-types}), требуется воспользоваться правилом развёртки рекурсивного типа~\eqref{eq:unfold} и~\eqref{eq:unfold-ex}, как было показано на примере~\eqref{eq:unfold-example}.
Чтобы пользоваться методами с Self-типом нам требуется ввести аналог правила развёртки.

\begin{definition}
    \label{def:materialization}
    \term{Материализация Self-типа} --- подмена Self-типа в сигнатуре метода на тип ресивера в скоупе типа этого ресивера.
\end{definition}

Так для примера выше \texttt{Self} материализуется в \texttt{Derived} в его скоупе:
\[(base: Base.() -> \framebox{Derived}) \in scope(Derived)\]

Скоупы Self-типа $Self(A)$ и его границы $A$ совпадают с точностью до материализации Self-типов:
\[scope(A) \circeq scope(Self(A))\]


\subsection{Синтаксис Self-типов}

Чтобы добавить какой-либо синтаксис в язык, нужно сперва тщательно убедиться, что обратная совместимость исходных кодов не будет нарушена.
Если же нарушение неизбежно, то разработать политику по миграции кодовых баз пользователей на новые версии языка.
Однако это исследование не является задачей данной работы.
Поэтому мы будем считать, что идентификатор Self введён как ключевое слово языка.

Естественным образом возникает вопрос, можно ли вручную задавать границу Self-типа.
Например, в синтаксисе меток, аналогичным меткам ссылок на ресиверы (\mintinline{kotlin}|this@functionOrClass|).
Это могло бы быть реализовано, однако неизвестны весомые сценарии использования такой функциональности.

\begin{minted}{kotlin}
    class C {
        fun A.foo(): Self@C       /* (C) */ {
            fun B.bar(): Self@C   /* (C) */ = this@C
            fun B.baz(): Self@foo /* (A) */ = this@foo
            return B().bar() /* : Self(C) */
        }

        fun bar(c: C): Self {
            with(c) {
                return A().foo() /* C */
            }
        }
    }
\end{minted}

Другим применением меток Self-типа может быть использование их во вложенных классах:

\begin{minted}{kotlin}
    class Outer {
        // (1)
        inner class Inner {
            fun getOuter(): Self@Outer = this@Outer
        }

        // (2)
        fun out(): Out<Self> = object : Out<Self> {
            override fun produce(): Self@Outer = this@Outer
        }
    }
\end{minted}

Для (1) снова не известны приложения.
Однако (2) было бы естественно поддержать, в случае, если Self-тип может присутствовать в позиции типового аргумента (будет рассмотрено далее в~\ref{subsec:self-positions}).


\subsection{Правила Self-типов}

TODO % TODO

\subsubsection{Подтипизация}

\begin{enumerate}
    \item \label{itm:covariant-bound} $B <: A \iff Self(B) <: Self(A)$ для возможности переопределения методов с \texttt{Self}
    \item \label{itm:this-subtype} $B <: A \iff Self(B) <: A$, чтобы код с \mintinline{kotlin}|this| оставался типизируемым
    \item \label{itm:any-nothing} $Nothing <: Self(A)$ и $Self(A) <: Any$
    \item \label{itm:no-subtypes} $B \bcancel{<:} Self(A)$, если $B$ не подходит под правила (\ref{itm:covariant-bound}) и (\ref{itm:any-nothing})
\end{enumerate}

TODO % TODO

\subsubsection{Ближайшие супертипы}

TODO % TODO

\subsubsection{Определение ближайшего супертипа}

TODO % TODO

\subsubsection{Создание новых объектов Self-типа}

Ранее мы подразумевали, что существует лишь одно значение Self-типа~--- \mintinline{kotlin}|this|.
Однако для многих важных приложений, например персистентных коллекций, требуется уметь создавать новые объекты Self-типа.
Оказывается, во многих случаях это делать небезопасно.
Так, присвоение Self-типа новым объектам открытых классов\footnote{\term{Открытый класс} --- класс, которой можно использовать как базовый при объявлении других классов.} и в открытых классах недопустимо:

\begin{minted}{kotlin}
    open class A {
        // Создание объекта открытого класса
        fun newOfOpenA(): Self = A()
        // Создание объекта в открытом классе
        fun newOtherQ(): Self = Q()
    }

    class Q : A() { fun qOnly() {} }
    class P : A() { fun pOnly() {} }

    fun test(q: Q, p: P) {
        q.newOfOpenA() // скоуп типа Q для A
         .qOnly()      #\err#
        p.newOther()   // скоуп типа P для Q
         .pOnly()      #\err#
    }
\end{minted}

Проблемы возникают из-за того, что при материализации Self-тип может стать произвольным наследником своей границы.
Поэтому, чтобы мочь новому объекту \texttt{C(..)} безопасно присвоить Self-тип необходимо добиться, чтобы его тип всегда был подтипом типа ресивера времени исполнения\footnote{Пусть \mintinline{kotlin}|this@decl| --- ссылка на ресивер ближайшей декларации.}:
\mintinline{kotlin}|C::class isSubtypeOf this@decl.getClass()|.

Среди промышленных языков, описанных в главе~\ref{sec:impls}, ни один не поддерживает какие-либо значения Self-типа, кроме ссылки на ресивер (\mintinline{kotlin}|this| или \mintinline{swift}|self|).
Однако в литературе~\ref{subsec:formals} приводятся ряд способов безопасно протипизировать новое значение Self-типом.

Первый способ --- ненаследуемые методы~\cite{saito2009matching}.

TODO % TODO


\subsection{Позиции Self-типа} \label{subsec:self-positions}

TODO % TODO


\subsection{Материализация Self-типа}

TODO % TODO


\subsection{Экспериментальная реализация Self-типов в компиляторе kotlinc}

TODO % TODO
